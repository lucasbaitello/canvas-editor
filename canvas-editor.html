<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor de Mosaico e Canvas</title>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script src="https://unpkg.com/packery@2/dist/packery.pkgd.min.js"></script>
    <script src="https://unpkg.com/imagesloaded@5/imagesloaded.pkgd.min.js"></script>
    <script src="https://unpkg.com/draggabilly@2/dist/draggabilly.pkgd.min.js"></script>
    <script src="fabric.js"></script>
    <style>
        body {
            font-family: Verdana, Geneva, sans-serif;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }
        
        /* Estilos para as abas */
        .tabs {
            display: flex;
            background-color: #efefef;
            padding: 0;
            margin: 0;
            list-style: none;
        }
        
        .tab {
            padding: 15px 25px;
            color: rgba(52, 52, 52, 0.993);
            cursor: pointer;
            transition: background-color 0.3s;
            font-weight: bold;
        }
        
        .tab:hover {
            background-color: #c9c9c9;
        }
        
        .tab.active {
            background-color: #a7a7a7;
        }
        
        /* Estilos para os conteúdos das abas */
        .tab-content {
            display: none;
            padding: 10px;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Estilos do mosaico (copiados do index.html) */
        .grid {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            transition: max-width 0.3s ease;
        }
        
        .grid-item {
            width: 200px;
            margin: 5px;
            cursor: move;
            position: relative;
            z-index: 1;
            border-radius: 0px;
            overflow: hidden;
        }
        
        .grid-item.is-dragging {
            z-index: 2;
            opacity: 0.8;
        }
        
        .grid-item img {
            width: 100%;
            display: block;
        }
        
        .grid-item.selected {
            outline: 5px solid #4a90e2;
            z-index: 2;
        }
        
        .resize-button {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: transparent;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 16px;
            display: none;
            cursor: pointer;
            z-index: 3;
        }
        
        .grid-item:hover .resize-button {
            display: block;
        }
        
        #global-resize-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: none;
            z-index: 1000;
            width: 250px;
        }
        
        #global-resize-menu.active {
            display: block;
        }
        
        #global-resize-menu label {
            display: block;
            margin-bottom: 5px;
            font-weight: normal;
            font-size: 13px;
        }
        
        #global-resize-menu .checkbox-container {
            margin: 10px 0;
        }
        
        #global-resize-menu .checkbox-container label {
            display: inline;
            margin-left: 5px;
        }
        
        #global-resize-menu input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
        }
        
        #global-resize-menu .percentage-value {
            display: inline-block;
            margin-left: 5px;
        }
        
        #uploadButton, #selectAllButton, #resetButton, #exportButton {
            margin: 15px 5px;
            padding: 8px 16px;
            font-size: 14px;
            cursor: pointer;
            background-color: #4a90e2;
            color: white;
            border: none;
            border-radius: 4px;
        }
        
        /* Estilos para os controles deslizantes */
        .controls {
            background-color: #f5f5f5;
            padding: 8px;
            margin: 10px auto;
            max-width: 500px;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .slider-container {
            margin-bottom: 8px;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 3px;
            font-weight: normal;
            font-size: 13px;
        }
        
        .slider-container input[type="range"] {
            width: 100%;
            margin-top: 3px;
            height: 8px;
        }
        
        .slider-value {
            display: inline-block;
            margin-left: 8px;
            font-weight: normal;
            font-size: 12px;
        }
        
        /* Estilo para o container de checkbox no painel de controles */
        .controls .checkbox-container {
            margin: 10px 0;
            padding: 5px 0;
            border-top: 1px solid #e0e0e0;
        }
        
        .controls .checkbox-container label {
            display: inline;
            margin-left: 8px;
            font-weight: normal;
            font-size: 13px;
        }
        
        /* Dashboard mode styles removed */
        
        /* Estilos do editor de canvas (copiados do edit.html) */
        .canvas-container {
            margin: 20px;
            border: 1px solid #ccc;
        }
        
        .editor-controls {
            margin: 10px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            background-color: #f5f5f5;
            padding: 5px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .editor-controls button {
            margin: 5px;
            padding: 8px 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            border: 1px solid #ddd;
            background-color: white;
            transition: all 0.2s;
        }
        
        .editor-controls button:hover {
            background-color: #f0f8ff;
            border-color: #aaccff;
        }
        
        .editor-controls button svg {
            margin-right: 5px;
            width: 16px;
            height: 16px;
        }
        
        .color-picker {
            margin: 5px;
            height: 36px;
            border: 1px solid #ddd;
            border-radius: 3px;
            cursor: pointer;
        }
        
        /* Estilos para os menus de configuração */
        #textEditMenu, #drawingMenu, #imageMenu, #shapeConfigMenu, #pathEditMenu {
            position: absolute; /* Garante que todos os menus sejam posicionados absolutamente */
            right: 20px;
            top: 150px;
            max-height: 80%;
            width: 210px;
            background: rgba(255, 255, 255, 0.522);
            border: 1px solid #80808091;
            border-radius:20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.15);
            z-index: 1000;
            padding: 9px;
            overflow-y: auto;
            display: none;
            font-size: 10px;
            cursor: move; /* Cursor indicando que o menu é arrastável */
        }
        
        /* Adicionar classe config-menu a todos os menus de configuração para facilitar seleção */
        #textEditMenu, #drawingMenu, #imageMenu, #shapeConfigMenu, #pathEditMenu {
            /* Adiciona a classe config-menu a todos os menus */
            display: none;
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #80808091;
            border-radius: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.15);
            z-index: 1000;
            padding: 9px;
            overflow-y: auto;
            font-size: 10px;
            transition: box-shadow 0.2s ease, opacity 0.2s ease;
            max-height: 80%;
            width: 210px;
        }
        
        .config-menu {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #80808091;
            border-radius: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.15);
            z-index: 1000;
            padding: 9px;
            overflow-y: auto;
            font-size: 10px;
            transition: box-shadow 0.2s ease, opacity 0.2s ease;
            max-height: 80%;
            width: 210px;
        }
        
        .config-menu.dragging {
            opacity: 0.9;
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
            transition: none; /* Desativa transições durante o arrasto para melhor desempenho */
        }
        
        /* Estilo específico para o menu de imagem */
        #imageMenu {
            z-index: 1001; /* Garante que fique acima dos outros menus */
        }
        
        #textEditMenu.active, #drawingMenu.active, #imageMenu.active, #shapeConfigMenu.active, #pathEditMenu.active {
            display: block;
        }
        
        .config-menu-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2px;
            padding: 5px;
            padding-bottom: 8px;
            border-bottom: 1px solid #ddd;
            cursor: grab;
            user-select: none; /* Impede seleção de texto ao arrastar */
            background-color: rgba(240, 240, 240, 0.5);
            border-radius: 15px 15px 0 0;
        }
        
        .config-menu-header:hover {
            background-color: rgba(230, 230, 230, 0.8);
        }
        
        .config-menu-header:active {
            cursor: grabbing;
        }
        
        .config-menu-header h8 {
            margin: 0;
            font-size: 11px;
        }
        
        /* Estilo para o toggle de preenchimento */
        .checkbox-container {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }
        
        .checkbox-container input[type="checkbox"] {
            margin-right: 5px;
        }
        
        .checkbox-container label {
            font-size: 10px;
        }
        
        .close-config-btn {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #666;
        }
        
        .active-tool {
            background-color: #4a90e2 !important;
            color: white !important;
            border-color: #2a70c2 !important;
        }
        
        /* Estilo para o menu dropdown de formas */
        #shapesDropdown {
            position: absolute;
            display: none;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            width: 200px;
        }
        
        #shapesDropdown button {
            display: block;
            width: 100%;
            text-align: left;
            margin: 5px 0;
            padding: 8px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
            border-radius: 4px;
        }
        
        #shapesDropdown button:hover {
            background-color: #f0f8ff;
        }
        
        /* Estilo para botões apenas com ícones */
        .icon-only-button {
            width: 40px;
            height: 40px;
            padding: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .icon-only-button svg {
            margin: 0;
        }
        
        /* Estilos para os botões superiores direitos */
        .top-right-buttons {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            gap: 10px;
        }
        
        .top-button {
            background-color: #ffffff;
            color: rgb(0, 0, 0);
            border: none;
            border-radius: 4px;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .top-button:hover {
            background-color: #818181;
        }
        
        .top-button svg {
            width: 16px;
            height: 16px;
        }
    </style>
</head>
<body>
    <!-- Abas de navegação -->
    <ul class="tabs">
        <li class="tab active" data-tab="mosaico">Mosaico de Imagens</li>
        <li class="tab" data-tab="editor">Editor de Canvas</li>
    </ul>
    
    <!-- Conteúdo da aba Mosaico -->
    <div id="mosaico" class="tab-content active">
        <input type="file" id="fileInput" multiple accept="image/*" style="display: none;">
        <button id="uploadButton">Selecionar Imagens</button>
        <button id="selectAllButton">Selecionar Todas</button>
        <button id="resetButton">Resetar </button>
        <button id="exportButton">Exportar Grid</button>
        
        <!-- Menu de redimensionamento global (popup) -->
        <div id="global-resize-menu">
            <label>Tamanho: <span class="percentage-value">100%</span></label>
            <input type="range" min="50" max="400" value="100" step="5">
            
            <div class="checkbox-container">
                <input type="checkbox" id="fixImageCheckbox">
                <label for="fixImageCheckbox">Fixar imagem</label>
            </div>
            
            <div class="multi-select-info" id="selectedCountInfo"></div>
        </div>
        
        <!-- Controles deslizantes para personalização -->
        <div class="controls">
            <div class="slider-container">
                <label for="imageSize">Tamanho das Imagens: <span class="slider-value" id="imageSizeValue">200</span>px</label>
                <input type="range" id="imageSize" min="50" max="500" value="200" step="10">
            </div>
            
            <div class="slider-container">
                <label for="imageGap">Espaçamento entre Imagens: <span class="slider-value" id="imageGapValue">5</span>px</label>
                <input type="range" id="imageGap" min="0" max="20" value="5" step="1">
            </div>
            
            <div class="slider-container">
                <label for="imageBorderRadius">Bordas Arredondadas: <span class="slider-value" id="imageBorderRadiusValue">0</span>px</label>
                <input type="range" id="imageBorderRadius" min="0" max="50" value="0" step="1">
            </div>
            
            <div class="slider-container">
                <label for="canvasWidth">Largura do Canvas: <span class="slider-value" id="canvasWidthValue">1200</span>px</label>
                <input type="range" id="canvasWidth" min="800" max="2000" value="1200" step="100">
            </div>
            
            <!-- Dashboard mode removed -->
        </div>
        
        <div class="grid">
            <!-- As imagens serão inseridas aqui -->
        </div>
    </div>
    
    <!-- Conteúdo da aba Editor -->
    <div id="editor" class="tab-content">
        <div class="editor-controls">
            <!-- Selecionar -->
            <button id="selectButton" title="Selecionar">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M4 4l7 17 3-10 10-3z"></path>
                </svg>
                Selecionar
            </button>
            
            <!-- Modo Desenho -->
            <button id="drawingButton" title="Modo Desenho">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25z"></path>
                    <path d="M20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"></path>
                </svg>
                Desenho
            </button>
            
            <!-- Formas -->
            <button id="shapesButton" title="Formas">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="3" width="7" height="7"></rect>
                    <rect x="14" y="3" width="7" height="7"></rect>
                    <rect x="14" y="14" width="7" height="7"></rect>
                    <circle cx="6.5" cy="17.5" r="3.5"></circle>
                </svg>
                Formas
            </button>
            
            <!-- Menu dropdown para formas -->
            <div id="shapesDropdown">
                <button id="addRectButton">Retângulo</button>
                <button id="addCircleButton">Círculo</button>
                <button id="addTriangleButton">Triângulo</button>
                <button id="addLineButton">Linha</button>
            </div>
            
            <!-- Adicionar Texto -->
            <button id="addTextButton" title="Adicionar Texto">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M5 5h14M12 5v14"></path>
                    <path d="M5 12h14"></path>
                </svg>
                Texto
            </button>
            
            <!-- Adicionar Imagem -->
            <button id="imageButton" title="Adicionar Imagem">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                    <circle cx="8.5" cy="8.5" r="1.5"></circle>
                    <path d="M21 15l-5-5L5 21"></path>
                </svg>
                Imagem
            </button>
            
            <!-- Botões de ordenação (remover duplicados e melhorar os ícones) -->
            <!-- Botão Trazer para Frente (uma camada) -->
            <button id="bringForwardButton" title="Trazer para Frente" class="icon-only-button">
                <svg fill="#000000" height="64px" width="64px" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="-33 -33 396.00 396.00" xml:space="preserve" transform="rotate(270)" stroke="#000000" stroke-width="33"><g id="SVGRepo_bgCarrier" stroke-width="5"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round" stroke="#0b0909" stroke-width="66"> <path id="XMLID_222_" d="M250.606,154.389l-150-149.996c-5.857-5.858-15.355-5.858-21.213,0.001 c-5.857,5.858-5.857,15.355,0.001,21.213l139.393,139.39L79.393,304.394c-5.857,5.858-5.857,15.355,0.001,21.213 C82.322,328.536,86.161,330,90,330s7.678-1.464,10.607-4.394l149.999-150.004c2.814-2.813,4.394-6.628,4.394-10.606 C255,161.018,253.42,157.202,250.606,154.389z"></path> </g><g id="SVGRepo_iconCarrier"> <path id="XMLID_222_" d="M250.606,154.389l-150-149.996c-5.857-5.858-15.355-5.858-21.213,0.001 c-5.857,5.858-5.857,15.355,0.001,21.213l139.393,139.39L79.393,304.394c-5.857,5.858-5.857,15.355,0.001,21.213 C82.322,328.536,86.161,330,90,330s7.678-1.464,10.607-4.394l149.999-150.004c2.814-2.813,4.394-6.628,4.394-10.606 C255,161.018,253.42,157.202,250.606,154.389z"></path> </g></svg>
            </button>

            <!-- Botão Enviar para Trás (uma camada) -->
            <button id="sendBackwardButton" title="Enviar para Trás" class="icon-only-button">
                <svg fill="#000000" height="64px" width="64px" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="-33 -33 396.00 396.00" xml:space="preserve" transform="rotate(270)matrix(-1, 0, 0, 1, 0, 0)" stroke="#000000" stroke-width="33"><g id="SVGRepo_bgCarrier" stroke-width="9"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round" stroke="#0b0909" stroke-width="66"> <path id="XMLID_222_" d="M250.606,154.389l-150-149.996c-5.857-5.858-15.355-5.858-21.213,0.001 c-5.857,5.858-5.857,15.355,0.001,21.213l139.393,139.39L79.393,304.394c-5.857,5.858-5.857,15.355,0.001,21.213 C82.322,328.536,86.161,330,90,330s7.678-1.464,10.607-4.394l149.999-150.004c2.814-2.813,4.394-6.628,4.394-10.606 C255,161.018,253.42,157.202,250.606,154.389z"></path> </g><g id="SVGRepo_iconCarrier"> <path id="XMLID_222_" d="M250.606,154.389l-150-149.996c-5.857-5.858-15.355-5.858-21.213,0.001 c-5.857,5.858-5.857,15.355,0.001,21.213l139.393,139.39L79.393,304.394c-5.857,5.858-5.857,15.355,0.001,21.213 C82.322,328.536,86.161,330,90,330s7.678-1.464,10.607-4.394l149.999-150.004c2.814-2.813,4.394-6.628,4.394-10.606 C255,161.018,253.42,157.202,250.606,154.389z"></path> </g></svg>

            </button>

            <!-- Botão Trazer para o Topo (topo de todas as camadas) -->
            <button id="bringToFrontButton" title="Trazer para o Topo" class="icon-only-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="9">
                    <path d="M7 11l5-5 5 5"></path>
                    <path d="M7 4h10"></path>
                </svg>
            </button>

            <!-- Botão Enviar para o Fundo (fundo de todas as camadas) -->
            <button id="sendToBackButton" title="Enviar para o Fundo" class="icon-only-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="9">
                    <path d="M7 13l5 5 5-5"></path>
                    <path d="M7 20h10"></path>
                </svg>
            </button>
            
            <!-- Excluir Selecionado -->
            <button id="deleteButton" title="Excluir Selecionado">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"></path>
                    <line x1="10" y1="11" x2="10" y2="17"></line>
                    <line x1="14" y1="11" x2="14" y2="17"></line>
                </svg>
                Excluir
            </button>
            
            <!-- Limpar Canvas -->
            <button id="clearButton" title="Limpar Canvas">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 6h18M8 6V4a1 1 0 011-1h6a1 1 0 011 1v2M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6h14z"></path>
                </svg>
                Limpar
            </button>
            
            <!-- Salvar Projeto (JSON) -->
            <button id="saveProjectJSON" title="Salvar Projeto (JSON)" onclick="salvarProjetoJSON()">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2z"></path>
                    <path d="M17 21v-8H7v8"></path>
                    <path d="M7 3v5h8"></path>
                    <circle cx="12" cy="15" r="2"></circle>
                </svg>
                Salvar Projeto
            </button>
            
            <!-- Carregar Projeto (JSON) -->
            <button id="loadProjectJSON" title="Carregar Projeto (JSON)" onclick="carregarProjetoJSON()">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"></path>
                    <path d="M14 2v6h6"></path>
                    <path d="M12 12v6"></path>
                    <path d="M9 15h6"></path>
                </svg>
                Abrir
            </button>
            
            <!-- Salvar -->
            <button id="saveButton" title="Salvar">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2z"></path>
                    <path d="M17 21v-8H7v8M7 3v5h8"></path>
                </svg>
                Salvar
            </button>
            
            <!-- Caixa de cor -->
            <input type="color" id="colorPicker" class="color-picker" title="Selecionar Cor">
            
            <input type="file" id="imageUpload" accept="image/*" style="display: none;">
        </div>
        
        <canvas id="canvas"></canvas>
        
        <!-- Menus de configuração para elementos do canvas -->
        <div id="textEditMenu" class="config-menu">
            <div class="config-menu-header">
                <h4>Configuração de Texto</h4>
                <button class="close-config-btn">&times;</button>
            </div>
            <div class="form-group">
                <label for="fontFamily">Fonte:</label>
                <select id="fontFamily">
                    <option value="Arial">Arial</option>
                    <option value="Helvetica">Helvetica</option>
                    <option value="Times New Roman">Times New Roman</option>
                    <option value="Courier New">Courier New</option>
                    <option value="Verdana">Verdana</option>
                    <option value="Georgia">Georgia</option>
                </select>
            </div>
            <div class="form-group"> <br>
                <label for="fontSize">Tamanho da Fonte: <span id="fontSizeValue">20</span>px</label>
                <input type="range" id="fontSize" min="10" max="80" value="20" step="1">
            </div>
            <div class="form-group">
                <label for="textWidth">Largura:
                    <span id="textWidthValue">200</span>px</label> <br>
                <input type="range" id="textWidth" min="50" max="500" value="200" step="1">
            </div>             <div class="form-group">
                <label for="textHeight">Altura:
                     <span id="textHeightValue">50</span>px</label> <br>
                <input type="range" id="textHeight" min="20" max="500" value="50" step="1">
            </div>
            <div class="form-group">
                <label for="textColor">Cor do Texto:</label>
                <input type="color" id="textColor" value="#000000">
            </div> <br>
            <div class="form-group">
                <label for="textOpacity">Opacidade do Texto: <span id="textOpacityValue">100</span>%</label>
                <input type="range" id="textOpacity" min="0" max="100" value="100" step="1">
            </div>
            <div class="form-group">
                <label for="textBgColor">Cor de Fundo:</label>
                <input type="color" id="textBgColor" value="#ffffff"> <br> <br>
            </div>
            <div class="form-group">
                <label for="textBgOpacity">Opacidade do Fundo: <span id="textBgOpacityValue">100</span>%</label>
                <input type="range" id="textBgOpacity" min="0" max="100" value="100" step="1">
            </div>
            <div class="form-group">
                <button id="boldButton">B</button>
                <button id="italicButton"><i>I</i></button>
                <button id="underlineButton"><u>U</u></button>
            </div>
        </div>
        
        <div id="drawingMenu" class="config-menu">
            <div class="config-menu-header">
                <h3>Configuração de Desenho</h3>
                <button class="close-config-btn">&times;</button>
            </div>
            <div class="form-group">
                <label for="brushWidth">Espessura do Pincel: <span id="brushWidthValue">5</span>px</label>
                <input type="range" id="brushWidth" min="1" max="90" value="5" step="1">
            </div>
            <div class="form-group">
                <label for="brushColor">Cor do Pincel:</label>
                <input type="color" id="brushColor" value="#000000">
            </div> <br>
            <div class="form-group">
                <label for="brushOpacity">Opacidade do Pincel: <span id="brushOpacityValue">100</span>%</label>
                <input type="range" id="brushOpacity" min="0" max="100" value="100" step="1">
            </div>
        </div>
        
        <div id="shapeConfigMenu" class="config-menu">
            <div class="config-menu-header">
                <h3>Configuração de Forma</h3>
                <button class="close-config-btn">&times;</button>
            </div>
            <div class="form-group">
                <label for="shapeWidth">Largura: <span id="shapeWidthValue">100</span>px</label>
                <input type="range" id="shapeWidth" min="10" max="500" value="100" step="1">
            </div>
            <div class="form-group">
                <label for="shapeHeight">Altura: 
                     <span id="shapeHeightValue">100</span>px</label> <br>
                <input type="range" id="shapeHeight" min="10" max="500" value="100" step="1">
            </div>
            <div class="form-group"> <br>
                <label for="shapeStrokeWidth">Espessura da Borda: <span id="shapeStrokeWidthValue">2</span>px</label>
                <input type="range" id="shapeStrokeWidth" min="0" max="90" value="2" step="1">
            </div>
            <div class="form-group">
                <label for="shapeStrokeColor">Cor da Borda:</label>
                <input type="color" id="shapeStrokeColor" value="#000000">
            </div>
            <div class="form-group checkbox-container">
                <input type="checkbox" id="shapeFillToggle" checked>
                <label for="shapeFillToggle">Preenchimento</label>
            </div>
            <div class="form-group" id="shapeFillColorGroup">
                <label for="shapeFillColor">Cor de Preenchimento:</label>
                <input type="color" id="shapeFillColor" value="#ffffff">
            </div>
            <div class="form-group">
                <label for="shapeOpacity">Opacidade: <span id="shapeOpacityValue">100</span>%</label>
                <input type="range" id="shapeOpacity" min="0" max="100" value="100" step="1">
            </div>
        </div>
        
        <div id="imageMenu" class="config-menu">
            <div class="config-menu-header">
                <h3>Configuração de Imagem</h3>
                <button class="close-config-btn">&times;</button>
            </div>
            <div class="form-group">
                <label for="imageWidth">Largura: <span id="imageWidthValue">200</span>px</label>
                <input type="range" id="imageWidth" min="50" max="1000" value="200" step="1">
            </div>
            <div class="form-group">
                <label for="imageHeight">Altura: <span id="imageHeightValue">200</span>px</label> <br>
                <input type="range" id="imageHeight" min="50" max="1000" value="200" step="1">
            </div>
            <div class="form-group">
                <label for="imageOpacity">Opacidade: <span id="imageOpacityValue">100</span>%</label>
                <input type="range" id="imageOpacity" min="0" max="100" value="100" step="1">
            </div>
            <div class="form-group">
                <label for="imageBorderWidth">Borda: <span id="imageBorderWidthValue">0</span>px</label>
                <input type="range" id="imageBorderWidth" min="0" max="20" value="0" step="1">
            </div>
            <div class="form-group">
                <label for="imageBorderColor">Cor da Borda:</label>
                <input type="color" id="imageBorderColor" value="#000000">
            </div>
        </div>
        
        <div id="pathEditMenu" class="config-menu">
            <div class="config-menu-header">
                <h3>Configuração de Caminho</h3>
                <button class="close-config-btn">&times;</button>
            </div>
            <div class="form-group">
                <label for="pathStrokeWidth">Espessura: <span id="pathStrokeWidthValue">5</span>px</label>
                <input type="range" id="pathStrokeWidth" min="1" max="50" value="5" step="1">
            </div>
            <div class="form-group">
                <label for="pathStrokeColor">Cor:</label>
                <input type="color" id="pathStrokeColor" value="#000000">
            </div>
            <br>
            <div class="form-group">
                <label for="pathOpacity">Opacidade: <span id="pathOpacityValue">100</span>%</label>
                <input type="range" id="pathOpacity" min="0" max="100" value="100" step="1">
            </div>
            <div class="form-group">
                <label for="pathWidth">Largura: <span id="pathWidthValue">100</span>px</label>
                <input type="range" id="pathWidth" min="10" max="500" value="100" step="1">
            </div>
            <div class="form-group">
                <label for="pathHeight">Altura: <span id="pathHeightValue">100</span>px</label> <br>
                <input type="range" id="pathHeight" min="10" max="500" value="100" step="1">
            </div>
        </div>
    </div>
    
    <!-- Adicionar os botões de salvar e carregar na parte superior direita -->
    <div class="top-right-buttons">
        <button id="saveProjectButton" class="top-button" title="Salvar Projeto">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2z"></path>
                <path d="M17 21v-8H7v8"></path>
                <path d="M7 3v5h8"></path>
            </svg>
            Salvar Projeto
        </button>
        
        <button id="loadProjectButton" class="top-button" title="Carregar Projeto">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 12h18"></path>
                <path d="M3 6h18"></path>
                <path d="M3 18h18"></path>
                <path d="M15 3v7l4-4-4-3z"></path>
            </svg>
            Carregar Projeto
        </button>
    </div>
    
    <!-- Input para carregar o arquivo (invisível) -->
    <input type="file" id="loadProjectFile" accept=".json" style="display: none;">
    
    <script>
        // Variáveis globais
        let canvas;
        let pckry;
        let selectedItems = [];
        let currentItem = null;
        let canvasState = null;
        
        // Função para alternar entre as abas
        function setupTabs() {
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');
            
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // Remove a classe active de todas as abas e conteúdos
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(c => c.classList.remove('active'));
                    
                    // Adiciona a classe active na aba clicada e no conteúdo correspondente
                    tab.classList.add('active');
                    const tabId = tab.getAttribute('data-tab');
                    document.getElementById(tabId).classList.add('active');
                    
                    // Se mudar para a aba do editor e tiver uma imagem exportada, carrega-a
                    if (tabId === 'editor' && localStorage.getItem('exportedGridImage')) {
                        if (!canvas) {
                            initCanvas();
                        }
                    }
                });
            });
        }
        
        // Inicializa o Packery para o mosaico de imagens
        function initMosaico() {
            const grid = document.querySelector('.grid');
            
            // Inicializa o grid mode (dashboard mode removido)
            initGridMode(grid);
        }
        
        // Inicializa o modo grid (masonry layout)
        function initGridMode(grid) {
            // Configurações do Packery para o modo grid
            const packeryOptions = {
                itemSelector: '.grid-item',
                gutter: 5,
                percentPosition: true,
                initLayout: true,
                isInitLayout: true // Garantir que o layout seja inicializado
            };
            
            // Inicializa o Packery com as opções configuradas
            pckry = new Packery(grid, packeryOptions);
            
            // Torna os itens arrastáveis - seleciona TODOS os itens, não apenas os que não têm a classe is-draggable
            const gridItems = document.querySelectorAll('.grid-item');
            gridItems.forEach((item) => {
                // Remove any existing draggability first para evitar duplicação
                const existingDraggie = Draggabilly.data(item);
                if (existingDraggie) {
                    existingDraggie.destroy();
                    item.classList.remove('is-draggable');
                }
                
                // Apenas torna arrastável se não estiver fixado (stamped)
                if (!item.classList.contains('is-stamped')) {
                    // Cria uma nova instância do Draggabilly com configurações específicas
                    const draggie = new Draggabilly(item, {
                        // Configurações adicionais para melhorar o arrasto
                        containment: grid
                    });
                    
                    // Vincula os eventos do Draggabilly ao Packery
                    pckry.bindDraggabillyEvents(draggie);
                    item.classList.add('is-draggable');
                    
                    // Evento de início de arrasto
                    draggie.on('dragStart', function() {
                        item.classList.add('is-dragging');
                        console.log('Iniciando arrasto no modo grid');
                    });
                    
                    // Evento de fim de arrasto
                    draggie.on('dragEnd', function() {
                        item.classList.remove('is-dragging');
                        console.log('Finalizando arrasto no modo grid');
                        // Reposiciona os itens após o arrasto no modo grid
                        pckry.layout();
                    });
                }
            });
            
            // Configuração dos controles do mosaico
            setupMosaicoControls();
        }
        
        // Dashboard mode function removed
        
        // Inicializa o Canvas do Fabric.js
        function initCanvas() {
            try {
                console.log('Inicializando canvas...');
                const canvasElement = document.getElementById('canvas');
                if (!canvasElement) {
                    console.error('Elemento do canvas não encontrado!');
                    return;
                }
                
                // Cria o canvas do Fabric.js
                canvas = new fabric.Canvas('canvas', {
                    width: 1200,
                    height: 800,
                    backgroundColor: '#ffffff',
                    // Configurações para melhorar a seleção:
                    perPixelTargetFind: true, // Ativa a detecção por pixel preenchido
                    targetFindTolerance: 9,  // Tolerância de 4px para melhorar a precisão
                    preserveObjectStacking: true // Mantém a ordem dos objetos durante a seleção
                });
                
                console.log('Canvas inicializado com sucesso');
                
                // Configuração dos controles do editor
                setupEditorControls();
                
                // Adiciona listeners específicos para seleção e duplo clique
                setupCanvasEventListeners();
                
                // Carrega a imagem exportada do mosaico, se existir
                const exportedImage = localStorage.getItem('exportedGridImage');
                if (exportedImage) {
                    importGridToCanvas(exportedImage);
                }
            } catch (error) {
                console.error('Erro ao inicializar canvas:', error);
            }
        }
        
        // Configuração dos controles do mosaico
        function setupMosaicoControls() {
            // Não chama makeItemsDraggable() pois essa função está obsoleta
            // A funcionalidade de tornar os itens arrastáveis já está nas funções initGridMode e initDashboardMode
            
            // Configuração do menu de redimensionamento global
            const globalResizeMenu = document.getElementById('global-resize-menu');
            const globalSizeSlider = globalResizeMenu.querySelector('input[type="range"]');
            const globalPercentageValue = globalResizeMenu.querySelector('.percentage-value');
            const selectedCountInfo = document.getElementById('selectedCountInfo');
            const fixImageCheckbox = document.getElementById('fixImageCheckbox');
            
            // Adiciona evento de clique no grid para deselecionar todas as imagens quando clicar em área em branco
            document.querySelector('.grid').addEventListener('click', (e) => {
                // Verifica se o clique foi diretamente no grid (não em um item do grid)
                if (e.target.classList.contains('grid')) {
                    // Deseleciona todos os itens
                    const gridItems = document.querySelectorAll('.grid-item');
                    gridItems.forEach(item => {
                        item.classList.remove('selected');
                    });
                    // Limpa o array de itens selecionados
                    selectedItems = [];
                }
            });
            
            // Fecha o menu quando clicar fora dele
            document.addEventListener('click', (e) => {
                if (!globalResizeMenu.contains(e.target) && !e.target.classList.contains('resize-button')) {
                    globalResizeMenu.classList.remove('active');
                }
            });
            
            // Evento para o slider de redimensionamento global
            globalSizeSlider.addEventListener('input', () => {
                const scale = globalSizeSlider.value;
                globalPercentageValue.textContent = `${scale}%`;
                
                if (selectedItems.length > 0) {
                    // Redimensiona todos os itens selecionados mantendo suas proporções relativas
                    selectedItems.forEach(item => {
                        // Obtém a escala original do item quando o menu foi aberto
                        const originalScale = parseFloat(item.getAttribute('data-original-scale') || 100);
                        // Calcula a proporção relativa entre a escala atual e a original
                        const relativeScale = (scale / parseFloat(currentItem.getAttribute('data-original-scale') || 100));
                        // Calcula a nova escala para este item específico
                        const newScale = originalScale * relativeScale;
                        // Aplica a nova escala
                        const originalWidth = parseInt(item.getAttribute('data-original-width'));
                        const newWidth = (originalWidth * newScale) / 100;
                        item.style.width = `${newWidth}px`;
                        item.setAttribute('data-scale', newScale.toFixed(0));
                    });
                    pckry.layout();
                } else if (currentItem) {
                    // Redimensiona apenas o item atual (caso de fallback)
                    const originalWidth = parseInt(currentItem.getAttribute('data-original-width'));
                    const newWidth = (originalWidth * scale) / 100;
                    currentItem.style.width = `${newWidth}px`;
                    currentItem.setAttribute('data-scale', scale);
                    pckry.layout();
                }
            });
            
            // Evento para o checkbox de fixar imagem
            fixImageCheckbox.addEventListener('change', () => {
                const isStamped = fixImageCheckbox.checked;
                
                if (selectedItems.length > 0) {
                    // Fixa ou desfixa todos os itens selecionados
                    selectedItems.forEach(item => {
                        toggleStampItem(item, isStamped);
                    });
                    pckry.layout();
                } else if (currentItem) {
                    // Fixa ou desfixa o item atual (caso de fallback)
                    toggleStampItem(currentItem, isStamped);
                    pckry.layout();
                }
            });
            
            // Botão para selecionar/deselecionar todas as imagens
            document.getElementById('selectAllButton').addEventListener('click', () => {
                const gridItems = document.querySelectorAll('.grid-item');
                const allSelected = selectedItems.length === gridItems.length;
                
                gridItems.forEach(item => {
                    if (!allSelected) {
                        item.classList.add('selected');
                        if (!selectedItems.includes(item)) {
                            selectedItems.push(item);
                        }
                    } else {
                        item.classList.remove('selected');
                    }
                });
                
                if (allSelected) {
                    selectedItems = [];
                } else {
                    selectedItems = Array.from(gridItems);
                }
            });
            
            // Configuração dos sliders de personalização
            const imageSizeSlider = document.getElementById('imageSize');
            const imageGapSlider = document.getElementById('imageGap');
            const imageBorderRadiusSlider = document.getElementById('imageBorderRadius');
            const canvasWidthSlider = document.getElementById('canvasWidth');
            
            // Event listener para o slider de tamanho das imagens
            imageSizeSlider.addEventListener('input', () => {
                const size = imageSizeSlider.value;
                document.getElementById('imageSizeValue').textContent = size;
                
                const gridItems = document.querySelectorAll('.grid-item');
                gridItems.forEach(item => {
                    item.style.width = `${size}px`;
                    item.setAttribute('data-original-width', size);
                });
                
                pckry.layout();
            });
            
            // Event listener para o slider de espaçamento entre imagens
            imageGapSlider.addEventListener('input', () => {
                const gap = imageGapSlider.value;
                document.getElementById('imageGapValue').textContent = gap;
                
                pckry.options.gutter = parseInt(gap);
                
                const gridItems = document.querySelectorAll('.grid-item');
                gridItems.forEach(item => {
                    item.style.margin = `${gap}px`;
                });
                
                pckry.layout();
            });
            
            // Event listener para o slider de bordas arredondadas
            imageBorderRadiusSlider.addEventListener('input', () => {
                const radius = imageBorderRadiusSlider.value;
                document.getElementById('imageBorderRadiusValue').textContent = radius;
                
                const gridItems = document.querySelectorAll('.grid-item');
                gridItems.forEach(item => {
                    item.style.borderRadius = `${radius}px`;
                });
                
                pckry.layout();
            });
            
            // Event listener para o slider de largura do canvas
            canvasWidthSlider.addEventListener('input', () => {
                const width = canvasWidthSlider.value;
                document.getElementById('canvasWidthValue').textContent = width;
                
                document.querySelector('.grid').style.maxWidth = `${width}px`;
                
                pckry.layout();
            });
            
            // Event listener para o toggle de modo de layout
            document.getElementById('layoutModeToggle').addEventListener('change', function() {
                const isDashboardMode = this.checked;
                const grid = document.querySelector('.grid');
                const dashboardIndicator = document.getElementById('dashboardIndicator');
                
                // Atualiza as classes do grid
                if (isDashboardMode) {
                    grid.classList.add('dashboard-mode');
                    dashboardIndicator.classList.add('active');
                } else {
                    grid.classList.remove('dashboard-mode');
                    dashboardIndicator.classList.remove('active');
                }
                
                // Reinicializa o Packery com as novas configurações de layout
                // Isso vai chamar a função apropriada baseada no modo selecionado
                initMosaico();
                
                // Se estiver saindo do modo dashboard, restaura o layout do grid
                if (!isDashboardMode) {
                    // Dá um tempo para o Packery inicializar antes de fazer o layout
                    setTimeout(() => {
                        pckry.layout();
                    }, 100);
                }
                
                console.log('Modo de layout alterado para: ' + (this.checked ? 'Dashboard' : 'Grid'));
            });
            
            // Botão para resetar todas as configurações
            document.getElementById('resetButton').addEventListener('click', () => {
                imageSizeSlider.value = 200;
                document.getElementById('imageSizeValue').textContent = '200';
                
                imageGapSlider.value = 5;
                document.getElementById('imageGapValue').textContent = '5';
                pckry.options.gutter = 5;
                
                imageBorderRadiusSlider.value = 0;
                document.getElementById('imageBorderRadiusValue').textContent = '0';
                
                canvasWidthSlider.value = 1200;
                document.getElementById('canvasWidthValue').textContent = '1200';
                document.querySelector('.grid').style.maxWidth = '1200px';
                
                const gridItems = document.querySelectorAll('.grid-item');
                gridItems.forEach(item => {
                    item.style.width = '200px';
                    item.style.margin = '5px';
                    item.style.borderRadius = '0px';
                    item.setAttribute('data-original-width', 200);
                });
                
                pckry.layout();
            });
            
            // Botão para exportar o grid
            document.getElementById('exportButton').addEventListener('click', () => {
                try {
                    console.log('Exportando grid do mosaico...');
                    
                    // Captura o grid usando html2canvas
                    html2canvas(document.querySelector('.grid')).then(canvas => {
                        // Converte o canvas para uma URL de dados
                        const imageData = canvas.toDataURL('image/png');
                        
                        // Armazena a imagem no localStorage para uso no editor
                        localStorage.setItem('exportedGridImage', imageData);
                        localStorage.setItem('gridWidth', document.querySelector('.grid').offsetWidth);
                        localStorage.setItem('gridHeight', document.querySelector('.grid').offsetHeight);
                        localStorage.setItem('lastExportTime', Date.now());
                        
                        console.log('Grid exportado com sucesso');
                        
                        // Se o canvas do editor já estiver inicializado, atualiza o fundo
                        if (window.canvas) {
                            // Muda para a aba do editor
                            document.querySelector('.tab[data-tab="editor"]').click();
                            
                            // Atualiza o fundo do canvas com a nova imagem
                            updateCanvasBackground(imageData);
                            
                            console.log('Canvas atualizado com o novo grid exportado');
                        } else {
                            // Muda para a aba do editor
                            document.querySelector('.tab[data-tab="editor"]').click();
                            console.log('Canvas será inicializado com o novo grid');
                        }
                    }).catch(error => {
                        console.error('Erro ao capturar o grid:', error);
                    });
                } catch (error) {
                    console.error('Erro ao exportar grid:', error);
                }
            });
            
            // Função para atualizar o fundo do canvas com a nova imagem
            function updateCanvasBackground(imageData) {
                try {
                    if (!canvas) {
                        console.error('Canvas não inicializado!');
                        return;
                    }
                    
                    console.log('Atualizando fundo do canvas...');
                    
                    // Armazenar os objetos atuais do canvas
                    const currentObjects = canvas.getObjects();
                    console.log(`Preservando ${currentObjects.length} objetos existentes no canvas`);
                    
                    // Obter as dimensões do grid
                    const gridWidth = parseInt(localStorage.getItem('gridWidth')) || 1200;
                    const gridHeight = parseInt(localStorage.getItem('gridHeight')) || 800;
                    
                    // Calcular dimensões preservando a proporção
                    const maxWidth = window.innerWidth * 0.9; // 90% da largura da janela
                    const maxHeight = window.innerHeight * 0.8; // 80% da altura da janela
                    
                    let canvasWidth = gridWidth;
                    let canvasHeight = gridHeight;
                    
                    // Redimensionar se a imagem for muito grande
                    if (canvasWidth > maxWidth || canvasHeight > maxHeight) {
                        const ratio = Math.min(maxWidth / canvasWidth, maxHeight / canvasHeight);
                        canvasWidth *= ratio;
                        canvasHeight *= ratio;
                    }
                    
                    // Redimensionar o canvas para caber o conteúdo mantendo a proporção
                    canvas.setWidth(canvasWidth);
                    canvas.setHeight(canvasHeight);
                    
                    // Criar um objeto fabric.Image a partir da URL de dados
                    fabric.Image.fromURL(imageData, function(img) {
                        // Calcular a escala para caber no canvas preservando a proporção
                        const scaleX = canvasWidth / img.width;
                        const scaleY = canvasHeight / img.height;
                        
                        // IMPORTANTE: Não use canvas.clear() aqui, pois isso removeria todos os objetos
                        // Apenas atualizamos a imagem de fundo, mantendo todos os objetos do canvas
                        
                        // Definir a imagem como imagem de fundo (não editável)
                        canvas.setBackgroundImage(img, function() {
                            // Após definir o background, renderizar o canvas
                            canvas.renderAll();
                            console.log('Fundo do canvas atualizado com sucesso, mantendo os objetos existentes');
                        }, {
                            scaleX: scaleX,
                            scaleY: scaleY,
                            originX: 'left',
                            originY: 'top'
                        });
                    });
                } catch (error) {
                    console.error('Erro ao atualizar o fundo do canvas:', error);
                }
            }
            
            // Modificar a função importGridToCanvas para utilizar a nova função updateCanvasBackground
            function importGridToCanvas(imageData) {
                if (!canvas) {
                    console.error('Canvas não inicializado para importar grid!');
                    return;
                }
                
                updateCanvasBackground(imageData);
            }
            
            // Adicionar verificação de atualização ao mudar para a aba do editor
            document.querySelector('.tab[data-tab="editor"]').addEventListener('click', function() {
                // Se o canvas já estiver inicializado e houver um grid exportado recentemente
                if (canvas && localStorage.getItem('exportedGridImage') && localStorage.getItem('lastExportTime')) {
                    const lastExportTime = parseInt(localStorage.getItem('lastExportTime'));
                    const currentTime = Date.now();
                    
                    // Se o grid foi exportado nos últimos 5 segundos
                    if (currentTime - lastExportTime < 5000) {
                        // Atualiza o fundo do canvas com o grid exportado
                        const imageData = localStorage.getItem('exportedGridImage');
                        updateCanvasBackground(imageData);
                        console.log('Canvas atualizado automaticamente com o último grid exportado');
                    }
                }
            });
            
            // Configuração do upload de imagens
            document.getElementById('uploadButton').addEventListener('click', () => {
                document.getElementById('fileInput').click();
            });
            
            document.getElementById('fileInput').addEventListener('change', (event) => {
                const files = event.target.files;
                
                for (let file of files) {
                    if (file.type.startsWith('image/')) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const div = document.createElement('div');
                            div.className = 'grid-item';
                            
                            // Aplicar as configurações atuais dos sliders ao novo item
                            const currentSize = document.getElementById('imageSize').value;
                            const currentBorderRadius = document.getElementById('imageBorderRadius').value;
                            
                            div.style.width = `${currentSize}px`;
                            div.style.borderRadius = `${currentBorderRadius}px`;
                            
                            const img = document.createElement('img');
                            img.src = e.target.result;
                            
                            // Adiciona a imagem ao item
                            div.appendChild(img);
                            document.querySelector('.grid').appendChild(div);
                            
                            imagesLoaded(div).on('progress', () => {
                                pckry.appended(div);
                                pckry.layout();
                                
                                // Configura os controles do item
                                setupItemControls(div);
                                
                                // Torna o novo item arrastável baseado no modo atual
                                const isDashboardMode = document.getElementById('layoutModeToggle')?.checked || false;
                                const draggie = new Draggabilly(div, {
                                    containment: document.querySelector('.grid')
                                });
                                
                                // Vincula os eventos do Draggabilly ao Packery
                                pckry.bindDraggabillyEvents(draggie);
                                div.classList.add('is-draggable');
                                
                                // Evento de início de arrasto
                                draggie.on('dragStart', function() {
                                    div.classList.add('is-dragging');
                                    console.log('Iniciando arrasto de novo item');
                                });
                                
                                // Evento de fim de arrasto
                                draggie.on('dragEnd', function() {
                                    div.classList.remove('is-dragging');
                                    console.log('Finalizando arrasto de novo item');
                                    if (!isDashboardMode) {
                                        // Reposiciona os itens após o arrasto no modo grid
                                        pckry.layout();
                                    } else {
                                        // Ajusta o item na posição mais próxima no modo dashboard
                                        pckry.fit(div);
                                    }
                                })
                            });
                        };
                        reader.readAsDataURL(file);
                    }
                }
            });
        }
        
        // Torna os itens do grid arrastáveis
        function makeItemsDraggable() {
            // Esta função agora está obsoleta, pois a funcionalidade foi movida para
            // as funções initGridMode e initDashboardMode
            console.log('makeItemsDraggable está obsoleta, usando funções específicas de modo');
            
            // Não faz nada, pois a funcionalidade foi movida para as funções específicas de modo
            // Mantida apenas para compatibilidade com código existente
        }
        
        // Configura os controles de cada item do grid
        function setupItemControls(item) {
            // Adiciona evento de clique para seleção
            item.addEventListener('click', (e) => {
                if (e.target.classList.contains('resize-button') || e.target === item.querySelector('.resize-button')) {
                    return;
                }
                
                if (item.classList.contains('selected')) {
                    item.classList.remove('selected');
                    const index = selectedItems.indexOf(item);
                    if (index > -1) {
                        selectedItems.splice(index, 1);
                    }
                } else {
                    item.classList.add('selected');
                    if (!selectedItems.includes(item)) {
                        selectedItems.push(item);
                    }
                }
            });
            
            // Configura o botão de redimensionamento
            const resizeButton = item.querySelector('.resize-button') || document.createElement('button');
            if (!item.querySelector('.resize-button')) {
                resizeButton.className = 'resize-button';
                resizeButton.innerHTML = '⚙️';
                resizeButton.title = 'Ajustar tamanho';
                item.appendChild(resizeButton);
            }
            
            // Armazena o tamanho original do item para cálculos de porcentagem
            if (!item.hasAttribute('data-original-width')) {
                item.setAttribute('data-original-width', item.offsetWidth);
                item.setAttribute('data-scale', 100); // Escala inicial de 100%
            }
            
            // Evento de clique no botão para mostrar o menu global
            resizeButton.addEventListener('click', (e) => {
                e.stopPropagation(); // Impede que o clique afete o arrasto
                
                // Posiciona o menu no centro da tela como um popup
                const globalResizeMenu = document.getElementById('global-resize-menu');
                globalResizeMenu.style.top = '50%';
                globalResizeMenu.style.left = '50%';
                globalResizeMenu.style.transform = 'translate(-50%, -50%)';
                
                // Verifica se há outros itens selecionados além deste
                const otherSelectedItems = selectedItems.filter(selItem => selItem !== item);
                
                // Se este item não está selecionado, limpa a seleção atual e seleciona apenas este
                if (!item.classList.contains('selected')) {
                    selectedItems.forEach(selItem => selItem.classList.remove('selected'));
                    selectedItems = [item];
                    item.classList.add('selected');
                }
                
                // Atualiza o slider com o valor atual do item clicado
                const currentScale = item.getAttribute('data-scale') || 100;
                const globalSizeSlider = globalResizeMenu.querySelector('input[type="range"]');
                const globalPercentageValue = globalResizeMenu.querySelector('.percentage-value');
                globalSizeSlider.value = currentScale;
                globalPercentageValue.textContent = `${currentScale}%`;
                
                // Mostra o menu e armazena o item atual
                globalResizeMenu.classList.add('active');
                currentItem = item;
                
                // Atualiza a informação de quantos itens estão selecionados
                const selectedCountInfo = document.getElementById('selectedCountInfo');
                if (selectedItems.length > 1) {
                    selectedCountInfo.textContent = `${selectedItems.length} imagens selecionadas`;
                } else {
                    selectedCountInfo.textContent = '';
                }
                
                // Armazena as escalas originais de cada item selecionado
                selectedItems.forEach(selItem => {
                    if (!selItem.hasAttribute('data-original-scale')) {
                        selItem.setAttribute('data-original-scale', selItem.getAttribute('data-scale') || 100);
                    }
                });
            });
        }
        
        // Função para alternar o estado de fixação (stamp) de um item
        function toggleStampItem(item, isStamped) {
            const isDashboardMode = document.getElementById('layoutModeToggle')?.checked || false;
            
            if (isStamped) {
                item.classList.add('is-stamped');
                
                // Encontra e destrói a instância Draggabilly associada ao item
                const draggie = Draggabilly.data(item);
                if (draggie) {
                    draggie.destroy();
                    item.classList.remove('is-draggable');
                }
                
                // No modo dashboard, mantém o item arrastável mesmo quando fixado
                if (!isDashboardMode) {
                    // Fixa o item no Packery
                    pckry.stamp(item);
                } else {
                    // No modo dashboard, cria uma nova instância do Draggabilly mesmo para itens fixados
                    const newDraggie = new Draggabilly(item, {
                        containment: document.querySelector('.grid')
                    });
                    pckry.bindDraggabillyEvents(newDraggie);
                    item.classList.add('is-draggable');
                    
                    newDraggie.on('dragStart', function() {
                        item.classList.add('is-dragging');
                    });
                    
                    newDraggie.on('dragEnd', function() {
                        item.classList.remove('is-dragging');
                        // Não reposiciona automaticamente no modo dashboard
                        pckry.fit(item);
                    });
                }
            } else {
                item.classList.remove('is-stamped');
                
                // Encontra e destrói a instância Draggabilly associada ao item
                const draggie = Draggabilly.data(item);
                if (draggie) {
                    draggie.destroy();
                    item.classList.remove('is-draggable');
                }
                
                // Desfixa o item no Packery
                if (!isDashboardMode) {
                    pckry.unstamp(item);
                }
                
                // Torna o item arrastável novamente em ambos os modos
                const newDraggie = new Draggabilly(item, {
                    containment: document.querySelector('.grid')
                });
                pckry.bindDraggabillyEvents(newDraggie);
                item.classList.add('is-draggable');
                
                newDraggie.on('dragStart', function() {
                    item.classList.add('is-dragging');
                });
                
                newDraggie.on('dragEnd', function() {
                    item.classList.remove('is-dragging');
                    if (!isDashboardMode) {
                        // Reposiciona os itens após o arrasto no modo grid
                        pckry.layout();
                    } else {
                        // Ajusta o item na posição mais próxima no modo dashboard
                        pckry.fit(item);
                    }
                });
            }
            
            // Atualiza o layout apenas no modo grid
            if (!isDashboardMode) {
                pckry.layout();
            }
        }
        
        // Configuração dos controles do editor
        function setupEditorControls() {
            // Botão de seleção
            document.getElementById('selectButton').addEventListener('click', () => {
                try {
                    console.log('Ativando modo de seleção precisa por pixel...');
                    
                    // Desativa o modo de desenho
                    canvas.isDrawingMode = false;
                    
                    // Garante que a seleção por pixel está ativa
                    canvas.perPixelTargetFind = true;
                    canvas.targetFindTolerance = 10;
                    
                    // Destaca o botão de seleção e remove destaque do botão de desenho
                    document.getElementById('selectButton').classList.add('active-tool');
                    document.getElementById('drawingButton').classList.remove('active-tool');
                    
                    // Esconde todos os menus de configuração
                    hideAllConfigMenus();
                    
                    console.log('Modo de seleção precisa ativado!');
                } catch (error) {
                    console.error('Erro ao ativar modo de seleção:', error);
                }
            });
            
            // Adiciona event listeners para botões de Salvar e Carregar Projeto
            // Botão para salvar projeto como JSON
            const saveProjectButton = document.getElementById('saveProjectJSON');
            if (saveProjectButton) {
                saveProjectButton.addEventListener('click', saveProjectAsJSON);
                console.log('Botão de salvar projeto configurado');
            } else {
                console.error('Botão de salvar projeto não encontrado!');
            }
            
            // Botão para carregar projeto de JSON
            const loadProjectButton = document.getElementById('loadProjectJSON');
            if (loadProjectButton) {
                loadProjectButton.addEventListener('click', function() {
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.accept = '.json';
                    fileInput.style.display = 'none';
                    document.body.appendChild(fileInput);
                    
                    fileInput.onchange = function(e) {
                        loadProjectFromJSON(e);
                        document.body.removeChild(fileInput);
                    };
                    
                    fileInput.click();
                });
                console.log('Botão de carregar projeto configurado');
            } else {
                console.error('Botão de carregar projeto não encontrado!');
            }

            // Botão de desenho
            document.getElementById('drawingButton').addEventListener('click', () => {
                // Desativa o modo de seleção e ativa o modo de desenho
                canvas.isDrawingMode = true;
                canvas.freeDrawingBrush.width = 5;
                canvas.freeDrawingBrush.color = document.getElementById('colorPicker').value;
                
                // Destaca o botão de desenho e remove destaque do botão de seleção
                document.getElementById('drawingButton').classList.add('active-tool');
                document.getElementById('selectButton').classList.remove('active-tool');
                
                // Mostra o menu de configuração de desenho
                hideAllConfigMenus();
                document.getElementById('drawingMenu').style.display = 'block';
                document.getElementById('brushColor').value = canvas.freeDrawingBrush.color;
                document.getElementById('brushWidth').value = canvas.freeDrawingBrush.width;
                document.getElementById('brushWidthValue').textContent = canvas.freeDrawingBrush.width;
            });
            
            // Botão de texto
            document.getElementById('addTextButton').addEventListener('click', () => {
                const text = new fabric.IText('Texto', {
                    left: 100,
                    top: 100,
                    fontFamily: 'Arial',
                    fill: document.getElementById('colorPicker').value,
                    fontSize: 20
                });
                canvas.add(text);
                canvas.setActiveObject(text);
                
                // Mostra o menu de configuração de texto
                hideAllConfigMenus();
                document.getElementById('textEditMenu').style.display = 'block';
                document.getElementById('fontFamily').value = text.fontFamily;
                document.getElementById('fontSize').value = text.fontSize;
                document.getElementById('fontSizeValue').textContent = text.fontSize;
                document.getElementById('textColor').value = text.fill;
                document.getElementById('textBgColor').value = text.backgroundColor || '#ffffff';
            });
            
            // Botão de imagem
            document.getElementById('imageButton').addEventListener('click', () => {
                document.getElementById('imageUpload').click();
            });
            
            document.getElementById('imageUpload').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (f) => {
                        const data = f.target.result;
                        fabric.Image.fromURL(data, (img) => {
                            // Redimensiona a imagem se for muito grande
                            if (img.width > canvas.width || img.height > canvas.height) {
                                const scale = Math.min(
                                    canvas.width / img.width, 
                                    canvas.height / img.height
                                ) * 0.4;
                                img.scale(scale);
                            }
                            canvas.add(img);
                            canvas.setActiveObject(img);
                            
                            // Exibe o menu de configuração de imagem
                            showImageMenu(img);
                            console.log('Imagem carregada e menu exibido');
                        });
                    };
                    reader.readAsDataURL(file);
                }
            });
            
            // Botão de excluir
            document.getElementById('deleteButton').addEventListener('click', () => {
                const activeObjects = canvas.getActiveObjects();
                if (activeObjects.length > 0) {
                    activeObjects.forEach(obj => {
                        canvas.remove(obj);
                    });
                    canvas.discardActiveObject();
                    canvas.requestRenderAll();
                }
            });
            
            // Botão de limpar
            document.getElementById('clearButton').addEventListener('click', () => {
                if (confirm('Tem certeza que deseja limpar todo o canvas?')) {
                    canvas.clear();
                    canvas.backgroundColor = '#ffffff';
                    canvas.renderAll();
                }
            });
            
            // Botão de salvar
            document.getElementById('saveButton').addEventListener('click', () => {
                const dataURL = canvas.toDataURL({
                    format: 'png',
                    quality: 1
                });
                const link = document.createElement('a');
                link.href = dataURL;
                link.download = 'canvas-image.png';
                link.click();
                document.body.removeChild(link);
            });
            
            // Seletor de cor
            document.getElementById('colorPicker').addEventListener('input', (e) => {
                const color = e.target.value;
                if (canvas.isDrawingMode) {
                    canvas.freeDrawingBrush.color = color;
                }
                const activeObjects = canvas.getActiveObjects();
                if (activeObjects.length > 0) {
                    activeObjects.forEach(obj => {
                        if (obj.type === 'i-text' || obj.type === 'text') {
                            obj.set('fill', color);
                        } else {
                            obj.set('stroke', color);
                            if (obj.fill && obj.fill !== 'transparent') {
                                obj.set('fill', color);
                            }
                        }
                    });
                    canvas.requestRenderAll();
                }
            });
            
            // Botão Trazer para Frente
            document.getElementById('bringForwardButton').addEventListener('click', () => {
                try {
                    const activeObject = canvas.getActiveObject();
                    if (activeObject) {
                        // Mover o objeto uma camada para cima
                        canvas.bringForward(activeObject);
                        canvas.renderAll();
                        console.log('Objeto trazido para frente');
                        
                        // Feedback visual para o usuário
                        const button = document.getElementById('bringForwardButton');
                        const originalBg = button.style.backgroundColor;
                        button.style.backgroundColor = '#4a90e2';
                        setTimeout(() => {
                            button.style.backgroundColor = originalBg;
                        }, 200);
                    } else {
                        console.log('Nenhum objeto selecionado para trazer para frente');
                    }
                } catch (error) {
                    console.error('Erro ao trazer objeto para frente:', error);
                }
            });
            
            // Botão Enviar para Trás
            document.getElementById('sendBackwardButton').addEventListener('click', () => {
                try {
                    const activeObject = canvas.getActiveObject();
                    if (activeObject) {
                        // Mover o objeto uma camada para baixo
                        canvas.sendBackwards(activeObject);
                        canvas.renderAll();
                        console.log('Objeto enviado para trás');
                        
                        // Feedback visual para o usuário
                        const button = document.getElementById('sendBackwardButton');
                        const originalBg = button.style.backgroundColor;
                        button.style.backgroundColor = '#4a90e2';
                        setTimeout(() => {
                            button.style.backgroundColor = originalBg;
                        }, 200);
                    } else {
                        console.log('Nenhum objeto selecionado para enviar para trás');
                    }
                } catch (error) {
                    console.error('Erro ao enviar objeto para trás:', error);
                }
            });
            
            // Botão Trazer para o Topo
            document.getElementById('bringToFrontButton').addEventListener('click', () => {
                try {
                    const activeObject = canvas.getActiveObject();
                    if (activeObject) {
                        // Mover o objeto para o topo de todas as camadas
                        canvas.bringToFront(activeObject);
                        canvas.renderAll();
                        console.log('Objeto trazido para o topo');
                        
                        // Feedback visual para o usuário
                        const button = document.getElementById('bringToFrontButton');
                        const originalBg = button.style.backgroundColor;
                        button.style.backgroundColor = '#4a90e2';
                        setTimeout(() => {
                            button.style.backgroundColor = originalBg;
                        }, 200);
                    } else {
                        console.log('Nenhum objeto selecionado para trazer para o topo');
                    }
                } catch (error) {
                    console.error('Erro ao trazer objeto para o topo:', error);
                }
            });

            // Botão Enviar para o Fundo
            document.getElementById('sendToBackButton').addEventListener('click', () => {
                try {
                    const activeObject = canvas.getActiveObject();
                    if (activeObject) {
                        // Mover o objeto para o fundo de todas as camadas
                        canvas.sendToBack(activeObject);
                        canvas.renderAll();
                        console.log('Objeto enviado para o fundo');
                        
                        // Feedback visual para o usuário
                        const button = document.getElementById('sendToBackButton');
                        const originalBg = button.style.backgroundColor;
                        button.style.backgroundColor = '#4a90e2';
                        setTimeout(() => {
                            button.style.backgroundColor = originalBg;
                        }, 200);
                    } else {
                        console.log('Nenhum objeto selecionado para enviar para o fundo');
                    }
                } catch (error) {
                    console.error('Erro ao enviar objeto para o fundo:', error);
                }
            });
        }
        
        // Função para importar a imagem do grid para o canvas
        function importGridToCanvas(imageData) {
            if (!canvas) {
                console.error('Canvas não inicializado para importar grid!');
                return;
            }
            
            updateCanvasBackground(imageData);
        }
        
        // Funções para gerenciar os menus de configuração
        function hideAllConfigMenus() {
            try {
                console.log('Escondendo todos os menus de configuração');
                document.querySelectorAll('.config-menu').forEach(menu => {
                    menu.style.display = 'none';
                });
                document.getElementById('shapesDropdown').style.display = 'none';
            } catch (error) {
                console.error('Erro ao esconder os menus:', error);
            }
        }
        
        function showTextMenu(textObj) {
            hideAllConfigMenus();
            const menu = document.getElementById('textEditMenu');
            menu.classList.add('active');
            
            // Atualiza os controles com os valores do objeto de texto
            document.getElementById('fontFamily').value = textObj.fontFamily;
            document.getElementById('fontSize').value = textObj.fontSize;
            document.getElementById('fontSizeValue').textContent = textObj.fontSize;
            document.getElementById('textColor').value = textObj.fill;
            document.getElementById('textBgColor').value = textObj.backgroundColor || '#ffffff';
        }
        
        function showShapeMenu(shapeObj) {
            hideAllConfigMenus();
            const menu = document.getElementById('shapeConfigMenu');
            menu.classList.add('active');
            
            // Atualiza os controles com os valores do objeto de forma
            document.getElementById('shapeStrokeColor').value = shapeObj.stroke || '#000000';
            document.getElementById('shapeStrokeWidth').value = shapeObj.strokeWidth || 2;
            document.getElementById('shapeStrokeWidthValue').textContent = shapeObj.strokeWidth || 2;
            document.getElementById('shapeFillColor').value = shapeObj.fill || '#ffffff';
            document.getElementById('shapeOpacity').value = shapeObj.opacity * 100 || 100;
            document.getElementById('shapeOpacityValue').textContent = Math.round(shapeObj.opacity * 100) || 100;
        }
        
        // Atualizar a função para exibir o menu de imagem
        function showImageMenu(imgObj) {
            try {
                console.log('Exibindo menu de configuração de imagem para:', imgObj);
                hideAllConfigMenus();
                const menu = document.getElementById('imageMenu');
                
                if (!menu) {
                    console.error('Menu de imagem não encontrado!');
                    return;
                }
                
                menu.style.display = 'block';
                menu.style.zIndex = '1001'; // Garante que fique acima de outros elementos
                
                // Atualiza os controles com os valores do objeto de imagem
                document.getElementById('imageOpacity').value = Math.round(imgObj.opacity * 100) || 100;
                document.getElementById('imageOpacityValue').textContent = Math.round(imgObj.opacity * 100) || 100;
                document.getElementById('imageBorderWidth').value = imgObj.strokeWidth || 0;
                document.getElementById('imageBorderWidthValue').textContent = imgObj.strokeWidth || 0;
                document.getElementById('imageBorderColor').value = imgObj.stroke || '#000000';
                
                console.log('Menu de imagem exibido com sucesso, display:', menu.style.display);
            } catch (error) {
                console.error('Erro ao exibir menu de imagem:', error);
            }
        }
        
        function showPathMenu(pathObj) {
            hideAllConfigMenus();
            const menu = document.getElementById('pathEditMenu');
            menu.classList.add('active');
            
            // Atualiza os controles com os valores do objeto de caminho
            document.getElementById('pathStrokeWidth').value = pathObj.strokeWidth || 5;
            document.getElementById('pathStrokeWidthValue').textContent = pathObj.strokeWidth || 5;
            document.getElementById('pathStrokeColor').value = pathObj.stroke || '#000000';
        }
        
        // Função para tornar os menus arrastáveis
        function makeMenusDraggable() {
            try {
                console.log('Configurando menus como arrastáveis...');
                
                // Seleciona todos os menus de configuração
                const menus = document.querySelectorAll('.config-menu');
                console.log(`Encontrados ${menus.length} menus para configurar como arrastáveis`);
                
                menus.forEach(menu => {
                    try {
                        console.log(`Configurando menu ${menu.id} como arrastável...`);
                        
                        // Primeiro remova quaisquer event listeners antigos clonando o elemento
                        const newMenu = menu.cloneNode(true);
                        menu.parentNode.replaceChild(newMenu, menu);
                        
                        // Garantir que o menu tenha position absolute
                        newMenu.style.position = 'absolute';
                        
                        // Seleciona o cabeçalho do menu como alça de arrasto
                        const header = newMenu.querySelector('.config-menu-header');
                        if (!header) {
                            console.warn(`Menu ${newMenu.id} não possui cabeçalho para arrastar.`);
                            return;
                        }
                        
                        // Adicionar cursor de arrasto ao cabeçalho
                        header.style.cursor = 'grab';
                        
                        let isDragging = false;
                        let offsetX, offsetY;
                        
                        // Função para iniciar o arrasto
                        function startDrag(e) {
                            // Verifica se o clique foi no botão de fechar
                            if (e.target.classList.contains('close-config-btn')) {
                                return;
                            }
                            
                            console.log(`Iniciando arrasto do menu ${newMenu.id}`);
                            e.preventDefault(); // Previne comportamento padrão
                            
                            isDragging = true;
                            
                            // Calcular o offset relativo ao menu, não ao cabeçalho
                            const menuRect = newMenu.getBoundingClientRect();
                            offsetX = e.clientX - menuRect.left;
                            offsetY = e.clientY - menuRect.top;
                            
                            // Mudar o cursor durante o arrasto
                            header.style.cursor = 'grabbing';
                            
                            // Adiciona uma classe para indicar que está sendo arrastado
                            newMenu.classList.add('dragging');
                            
                            // Trazer o menu para frente durante o arrasto
                            newMenu.style.zIndex = '1001';
                            
                            // Adiciona os eventos de movimento e finalização apenas quando começar a arrastar
                            document.addEventListener('mousemove', dragMenu);
                            document.addEventListener('mouseup', stopDrag);
                        }
                        
                        // Função para mover o menu durante o arrasto
                        function dragMenu(e) {
                            if (!isDragging) return;
                            
                            e.preventDefault(); // Previne comportamento padrão
                            
                            // Calcula a nova posição
                            let left = e.clientX - offsetX;
                            let top = e.clientY - offsetY;
                            
                            // Limites para não sair da tela
                            const windowWidth = window.innerWidth;
                            const windowHeight = window.innerHeight;
                            const menuWidth = newMenu.offsetWidth;
                            const menuHeight = newMenu.offsetHeight;
                            
                            // Garante que pelo menos 100px do menu esteja sempre visível
                            left = Math.max(-menuWidth + 100, Math.min(left, windowWidth - 100));
                            top = Math.max(0, Math.min(top, windowHeight - 50));
                            
                            // Aplica a nova posição
                            newMenu.style.left = left + 'px';
                            newMenu.style.top = top + 'px';
                            newMenu.style.right = 'auto'; // Remover right para evitar conflitos
                            
                            console.log(`Menu ${newMenu.id} movido para: left=${left}px, top=${top}px`);
                        }
                        
                        // Função para encerrar o arrasto
                        function stopDrag(e) {
                            if (isDragging) {
                                e.preventDefault(); // Previne comportamento padrão
                                
                                isDragging = false;
                                header.style.cursor = 'grab';
                                newMenu.classList.remove('dragging');
                                
                                // Restaurar z-index original
                                newMenu.style.zIndex = '1000';
                                
                                // Remove os event listeners para evitar vazamentos de memória
                                document.removeEventListener('mousemove', dragMenu);
                                document.removeEventListener('mouseup', stopDrag);
                                
                                console.log(`Arrasto do menu ${newMenu.id} finalizado`);
                            }
                        }
                        
                        // Adiciona o evento de mousedown apenas ao cabeçalho
                        header.addEventListener('mousedown', startDrag);
                        
                        // Configurar botão de fechar
                        const closeButton = newMenu.querySelector('.close-config-btn');
                        if (closeButton) {
                            closeButton.addEventListener('click', () => {
                                newMenu.style.display = 'none';
                                console.log(`Menu ${newMenu.id} fechado.`);
                            });
                        }
                        
                        console.log(`Menu ${newMenu.id} configurado como arrastável.`);
                    } catch (err) {
                        console.error(`Erro ao configurar menu como arrastável:`, err);
                    }
                });
                
                console.log('Todos os menus configurados como arrastáveis.');
            } catch (error) {
                console.error('Erro ao configurar menus arrastáveis:', error);
            }
        }
        
        // Função para garantir que todos os menus tenham a classe config-menu
        function ensureConfigMenuClass() {
            try {
                console.log('Verificando classes dos menus de configuração...');
                
                const menuIds = ['textEditMenu', 'drawingMenu', 'imageMenu', 'shapeConfigMenu', 'pathEditMenu'];
                
                menuIds.forEach(id => {
                    const menu = document.getElementById(id);
                    if (menu) {
                        if (!menu.classList.contains('config-menu')) {
                            menu.classList.add('config-menu');
                            console.log(`Classe config-menu adicionada ao menu: ${id}`);
                        }
                        
                        // Garantir que o menu tenha position absolute
                        menu.style.position = 'absolute';
                        
                        // Definir posição inicial se não estiver definida
                        if (!menu.style.top || !menu.style.left) {
                            menu.style.top = '150px';
                            menu.style.right = 'auto'; // Remover right para evitar conflitos
                            menu.style.left = '20px';
                        } else {
                            // Garantir que right seja auto mesmo se já tiver posição definida
                            menu.style.right = 'auto';
                        }
                        
                        // Garantir que o menu tenha um cabeçalho para arrastar
                        if (!menu.querySelector('.config-menu-header')) {
                            const header = document.createElement('div');
                            header.className = 'config-menu-header';
                            header.innerHTML = `<h3>${id.replace('Menu', ' Menu')}</h3><button class="close-config-btn">&times;</button>`;
                            header.style.cursor = 'grab'; // Adicionar cursor de arrasto ao cabeçalho
                            menu.prepend(header);
                        } else {
                            // Garantir que o cabeçalho existente tenha o cursor de arrasto
                            const header = menu.querySelector('.config-menu-header');
                            header.style.cursor = 'grab';
                        }
                    } else {
                        console.warn(`Menu não encontrado: ${id}`);
                    }
                });
                
                console.log('Verificação de classes de menus concluída');
            } catch (error) {
                console.error('Erro ao verificar classes dos menus:', error);
            }
        }
        
        // Chamar a função para garantir classes dos menus na inicialização
        document.addEventListener('DOMContentLoaded', function() {
            try {
                console.log('Inicializando aplicação...');
                
                // Configurar as abas
                setupTabs();
                
                // Inicializar o mosaico
                initMosaico();
                
                // Inicializar o canvas quando a aba do editor for selecionada pela primeira vez
                document.querySelector('.tab[data-tab="editor"]').addEventListener('click', function() {
                    if (!canvas) {
                        console.log('Inicializando o editor de canvas...');
                        initCanvas();
                        
                        // Configurar os menus como arrastáveis após breve delay para garantir que os elementos estejam prontos
                        setTimeout(() => {
                            // Garantir classes dos menus
                            ensureConfigMenuClass();
                            
                            makeMenusDraggable();
                            
                            // Configurar botões de fechar em todos os menus
                            document.querySelectorAll('.close-config-btn').forEach(btn => {
                                btn.addEventListener('click', function() {
                                    const menu = this.closest('.config-menu');
                                    if (menu) {
                                        menu.style.display = 'none';
                                        console.log(`Menu ${menu.id} fechado via botão.`);
                                    }
                                });
                            });
                            
                            // Criar o menu de formas
                            createShapesMenu();
                            
                            console.log('Menus configurados como arrastáveis.');
                        }, 500);
                    }
                });
                
                console.log('Inicialização concluída com sucesso!');
            } catch (error) {
                console.error('Erro durante a inicialização:', error);
            }
        });
        // Configuração do menu dropdown de formas
        document.getElementById('shapesButton').addEventListener('click', (e) => {
            console.log('Botão de formas clicado');
            const dropdown = document.getElementById('shapesDropdown');
            
            // Alternar visibilidade do dropdown
            if (dropdown.style.display === 'block') {
                dropdown.style.display = 'none';
                console.log('Menu de formas fechado');
            } else {
                // Posiciona o dropdown abaixo do botão
                const buttonRect = e.target.closest('button').getBoundingClientRect();
                dropdown.style.display = 'block';
                dropdown.style.top = `${buttonRect.bottom + 5}px`;
                dropdown.style.left = `${buttonRect.left}px`;
                console.log('Menu de formas aberto em:', buttonRect.left, buttonRect.bottom + 5);
                
                // Garantir que o menu de formas tenha o z-index maior que outros elementos
                dropdown.style.zIndex = '1002';
            }
        });
        
        // Fechar o dropdown quando clicar fora dele
        document.addEventListener('click', (e) => {
            if (!e.target.closest('#shapesButton') && !e.target.closest('#shapesDropdown')) {
                document.getElementById('shapesDropdown').style.display = 'none';
            }
        });
        
        // Adicionar eventos para os botões de formas
        document.getElementById('addRectButton').addEventListener('click', () => {
            try {
                console.log('Adicionando retângulo...');
                const rect = new fabric.Rect({
                    left: 100,
                    top: 100,
                    width: 200,
                    height: 80,
                    fill: document.getElementById('colorPicker').value,
                    stroke: '#FF0000',
                    strokeWidth: 2,
                    transparentCorners: true,
                    cornerColor: '#4a90e2',
                    cornerSize: 8,
                    // Propriedades para melhorar a seleção:
                    perPixelTargetFind: true
                });
                canvas.add(rect);
                canvas.setActiveObject(rect);
                document.getElementById('shapesDropdown').style.display = 'none';
                
                // Mostrar menu de configuração
                hideAllConfigMenus();
                document.getElementById('shapeConfigMenu').style.display = 'block';
                updateShapeMenu(rect);
                
                console.log('Retângulo adicionado com seleção por pixel');
            } catch (error) {
                console.error('Erro ao adicionar retângulo:', error);
            }
        });
        
        document.getElementById('addCircleButton').addEventListener('click', () => {
            try {
                console.log('Adicionando círculo...');
                const circle = new fabric.Circle({
                    left: 100,
                    top: 100,
                    radius: 50,
                    fill: document.getElementById('colorPicker').value,
                    stroke: '#000000',
                    strokeWidth: 2,
                    transparentCorners: true,
                    cornerColor: '#4a90e2',
                    cornerSize: 8,
                    // Propriedades para melhorar a seleção:
                    perPixelTargetFind: true
                });
                canvas.add(circle);
                canvas.setActiveObject(circle);
                document.getElementById('shapesDropdown').style.display = 'none';
                
                // Mostrar menu de configuração
                hideAllConfigMenus();
                document.getElementById('shapeConfigMenu').style.display = 'block';
                updateShapeMenu(circle);
                
                console.log('Círculo adicionado com seleção por pixel');
            } catch (error) {
                console.error('Erro ao adicionar círculo:', error);
            }
        });
        
        document.getElementById('addTriangleButton').addEventListener('click', () => {
            const triangle = new fabric.Triangle({
                left: 100,
                top: 100,
                width: 200,
                height: 200,
                fill: document.getElementById('colorPicker').value,
                stroke: '#a3a3a3',
                strokeWidth: 5
            });
            canvas.add(triangle);
            canvas.setActiveObject(triangle);
            showShapeMenu(triangle);
            document.getElementById('shapesDropdown').style.display = 'none';
        });
        
        document.getElementById('addLineButton').addEventListener('click', () => {
            const line = new fabric.Line([50, 50, 400, 50], {
                stroke: document.getElementById('colorPicker').value,
                strokeWidth: 5
            });
            canvas.add(line);
            canvas.setActiveObject(line);
            showShapeMenu(line);
            document.getElementById('shapesDropdown').style.display = 'none';
        });
        
        // Configuração dos menus de edição
        document.getElementById('fontFamily').addEventListener('change', (e) => {
            const activeObject = canvas.getActiveObject();
            if (activeObject && (activeObject.type === 'i-text' || activeObject.type === 'text')) {
                activeObject.set('fontFamily', e.target.value);
                canvas.renderAll();
            }
        });
        
        document.getElementById('fontSize').addEventListener('input', (e) => {
            const value = e.target.value;
            document.getElementById('fontSizeValue').textContent = value;
            const activeObject = canvas.getActiveObject();
            if (activeObject && (activeObject.type === 'i-text' || activeObject.type === 'text')) {
                activeObject.set('fontSize', parseInt(value));
                canvas.renderAll();
            }
        });
        
        document.getElementById('textColor').addEventListener('input', (e) => {
            const activeObject = canvas.getActiveObject();
            if (activeObject && (activeObject.type === 'i-text' || activeObject.type === 'text')) {
                activeObject.set('fill', e.target.value);
                canvas.renderAll();
            }
        });
        
        document.getElementById('textBgColor').addEventListener('input', (e) => {
            const activeObject = canvas.getActiveObject();
            if (activeObject && (activeObject.type === 'i-text' || activeObject.type === 'text')) {
                activeObject.set('backgroundColor', e.target.value);
                canvas.renderAll();
            }
        });
        
        document.getElementById('boldButton').addEventListener('click', () => {
            const activeObject = canvas.getActiveObject();
            if (activeObject && (activeObject.type === 'i-text' || activeObject.type === 'text')) {
                activeObject.set('fontWeight', activeObject.fontWeight === 'bold' ? 'normal' : 'bold');
                canvas.renderAll();
            }
        });
        
        document.getElementById('italicButton').addEventListener('click', () => {
            const activeObject = canvas.getActiveObject();
            if (activeObject && (activeObject.type === 'i-text' || activeObject.type === 'text')) {
                activeObject.set('fontStyle', activeObject.fontStyle === 'italic' ? 'normal' : 'italic');
                canvas.renderAll();
            }
        });
        
        document.getElementById('underlineButton').addEventListener('click', () => {
            const activeObject = canvas.getActiveObject();
            if (activeObject && (activeObject.type === 'i-text' || activeObject.type === 'text')) {
                activeObject.set('underline', !activeObject.underline);
                canvas.renderAll();
            }
        });
        
        // Configuração do menu de desenho
        document.getElementById('brushWidth').addEventListener('input', (e) => {
            const value = e.target.value;
            document.getElementById('brushWidthValue').textContent = value;
            canvas.freeDrawingBrush.width = parseInt(value);
        });
        
        document.getElementById('brushColor').addEventListener('input', (e) => {
            updateBrushColor(e.target.value);
        });
        
        document.getElementById('brushOpacity').addEventListener('input', (e) => {
            const value = e.target.value;
            document.getElementById('brushOpacityValue').textContent = value;
            updateBrushOpacity(value);
        });
        
        // Função para atualizar a cor do pincel considerando a opacidade
        function updateBrushColor(color) {
            try {
                const opacity = parseInt(document.getElementById('brushOpacity').value) / 100;
                if (canvas && canvas.isDrawingMode) {
                    // Converter hex para rgba
                    const r = parseInt(color.substr(1, 2), 16);
                    const g = parseInt(color.substr(3, 2), 16);
                    const b = parseInt(color.substr(5, 2), 16);
                    canvas.freeDrawingBrush.color = `rgba(${r},${g},${b},${opacity})`;
                    console.log('Cor do pincel atualizada para rgba(' + r + ',' + g + ',' + b + ',' + opacity + ')');
                }
            } catch (error) {
                console.error('Erro ao atualizar cor do pincel:', error);
            }
        }
        
        // Função para atualizar a opacidade do pincel
        function updateBrushOpacity(value) {
            try {
                const opacity = parseInt(value) / 100;
                const color = document.getElementById('brushColor').value;
                
                if (canvas && canvas.isDrawingMode) {
                    // Converter hex para rgba
                    const r = parseInt(color.substr(1, 2), 16);
                    const g = parseInt(color.substr(3, 2), 16);
                    const b = parseInt(color.substr(5, 2), 16);
                    canvas.freeDrawingBrush.color = `rgba(${r},${g},${b},${opacity})`;
                    console.log('Opacidade do pincel atualizada:', opacity);
                }
            } catch (error) {
                console.error('Erro ao atualizar opacidade do pincel:', error);
            }
        }
        
        // Event listeners para opacidade do texto
        document.getElementById('textOpacity').addEventListener('input', (e) => {
            try {
                const value = parseInt(e.target.value);
                document.getElementById('textOpacityValue').textContent = value;
                
                const activeObject = canvas.getActiveObject();
                if (activeObject && (activeObject.type === 'i-text' || activeObject.type === 'text')) {
                    activeObject.set('opacity', value / 100);
                    canvas.renderAll();
                    console.log('Opacidade do texto atualizada:', value / 100);
                }
            } catch (error) {
                console.error('Erro ao atualizar opacidade do texto:', error);
            }
        });
        
        // Event listener para opacidade do fundo do texto
        document.getElementById('textBgOpacity').addEventListener('input', (e) => {
            try {
                const value = parseInt(e.target.value);
                document.getElementById('textBgOpacityValue').textContent = value;
                
                const activeObject = canvas.getActiveObject();
                if (activeObject && (activeObject.type === 'i-text' || activeObject.type === 'text')) {
                    // Extrair a cor atual do fundo
                    const bgColor = activeObject.backgroundColor || '#ffffff';
                    
                    // Se a cor for no formato hex, convertê-la para rgba
                    if (bgColor.startsWith('#')) {
                        const r = parseInt(bgColor.substr(1, 2), 16);
                        const g = parseInt(bgColor.substr(3, 2), 16);
                        const b = parseInt(bgColor.substr(5, 2), 16);
                        
                        activeObject.set('backgroundColor', `rgba(${r},${g},${b},${value/100})`);
                        canvas.renderAll();
                        console.log('Opacidade do fundo do texto atualizada:', value / 100);
                    }
                }
            } catch (error) {
                console.error('Erro ao atualizar opacidade do fundo do texto:', error);
            }
        });
        
        // Configuração do menu de formas
        document.getElementById('shapeFillToggle').addEventListener('change', (e) => {
            try {
                const activeObject = canvas.getActiveObject();
                if (activeObject && activeObject.fill !== undefined) {
                    if (e.target.checked) {
                        // Ativar preenchimento
                        const fillColor = document.getElementById('shapeFillColor').value;
                        activeObject.set('fill', fillColor);
                        document.getElementById('shapeFillColorGroup').style.display = 'block';
                    } else {
                        // Desativar preenchimento
                        activeObject.set('fill', 'transparent');
                        document.getElementById('shapeFillColorGroup').style.display = 'none';
                    }
                    
                    // Atualizar a seleção por pixel (se transparente, será mais difícil selecionar)
                    if (activeObject.fill === 'transparent') {
                        // Para objetos sem preenchimento, permitimos seleção pela borda
                        console.log('Objeto sem preenchimento, ajustando seleção para borda...');
                        activeObject.perPixelTargetFind = true;
                        activeObject.strokeWidth = Math.max(2, activeObject.strokeWidth || 2); // Garante uma largura mínima para seleção
                    } else {
                        // Para objetos com preenchimento, mantemos a seleção por pixel padrão
                        activeObject.perPixelTargetFind = true;
                    }
                    
                    canvas.renderAll();
                    console.log('Preenchimento atualizado:', e.target.checked ? 'ativado' : 'desativado');
                }
            } catch (error) {
                console.error('Erro ao alterar preenchimento:', error);
            }
        });
        
        document.getElementById('shapeStrokeColor').addEventListener('input', (e) => {
            const activeObjects = canvas.getActiveObjects();
            if (activeObjects.length > 0) {
                activeObjects.forEach(obj => {
                    if (obj.stroke !== undefined) {
                        obj.set('stroke', e.target.value);
                    }
                });
                canvas.renderAll();
            }
        });
        
        document.getElementById('shapeStrokeWidth').addEventListener('input', (e) => {
            const value = e.target.value;
            document.getElementById('shapeStrokeWidthValue').textContent = value;
            const activeObjects = canvas.getActiveObjects();
            if (activeObjects.length > 0) {
                activeObjects.forEach(obj => {
                    if (obj.strokeWidth !== undefined) {
                        obj.set('strokeWidth', parseInt(value));
                    }
                });
                canvas.renderAll();
            }
        });
        
        document.getElementById('shapeFillColor').addEventListener('input', (e) => {
            const activeObjects = canvas.getActiveObjects();
            if (activeObjects.length > 0) {
                activeObjects.forEach(obj => {
                    if (obj.fill !== undefined && obj.fill !== 'transparent') {
                        obj.set('fill', e.target.value);
                    }
                });
                canvas.renderAll();
            }
        });
        
        document.getElementById('shapeOpacity').addEventListener('input', (e) => {
            const value = e.target.value;
            document.getElementById('shapeOpacityValue').textContent = value;
            const activeObjects = canvas.getActiveObjects();
            if (activeObjects.length > 0) {
                activeObjects.forEach(obj => {
                    obj.set('opacity', parseInt(value) / 100);
                });
                canvas.renderAll();
            }
        });
        
        // Função para mostrar menu para múltiplos objetos selecionados
        function showMultiSelectionMenu(objects) {
            hideAllConfigMenus();
            const menu = document.getElementById('shapeConfigMenu');
            menu.classList.add('active');
            
            // Atualizar título do menu
            menu.querySelector('h3').textContent = `Configuração (${objects.length} itens)`;
        }
        
        // Configurar os botões de fechar nos menus de configuração
        function setupCloseButtons() {
            document.querySelectorAll('.close-config-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    // Encontra o menu pai do botão de fechar
                    const menu = this.closest('.config-menu');
                    if (menu) {
                        menu.style.display = 'none';
                    }
                });
            });
        }
        
        // Adiciona os event listeners aos botões de fechar
        document.querySelectorAll('.close-config-btn').forEach(btn => {
            btn.addEventListener('click', hideAllConfigMenus);
        });
        
        // Configuração do menu de caminho (path)
        document.getElementById('pathStrokeWidth').addEventListener('input', (e) => {
            const value = e.target.value;
            document.getElementById('pathStrokeWidthValue').textContent = value;
            const activeObject = canvas.getActiveObject();
            if (activeObject && activeObject.type === 'path') {
                activeObject.set('strokeWidth', parseInt(value));
                canvas.renderAll();
            }
        });
        
        document.getElementById('pathStrokeColor').addEventListener('input', (e) => {
            const activeObject = canvas.getActiveObject();
            if (activeObject && activeObject.type === 'path') {
                activeObject.set('stroke', e.target.value);
                canvas.renderAll();
            }
        });
        
        // Mostrar menu de configuração quando um objeto é selecionado
        canvas.on('selection:created', function(options) {
            try {
                console.log('Seleção criada:', options);
                const obj = canvas.getActiveObject();
                if (!obj) return;
                
                showConfigMenuForObject(obj, 'selection:created');
            } catch (error) {
                console.error('Erro ao processar seleção criada:', error);
            }
        });
        
        canvas.on('selection:updated', function(options) {
            try {
                console.log('Seleção atualizada:', options);
                const obj = canvas.getActiveObject();
                if (!obj) return;
                
                showConfigMenuForObject(obj, 'selection:updated');
            } catch (error) {
                console.error('Erro ao processar seleção atualizada:', error);
            }
        });
        
        canvas.on('selection:cleared', function() {
            try {
                console.log('Seleção removida');
                hideAllConfigMenus();
            } catch (error) {
                console.error('Erro ao processar remoção de seleção:', error);
            }
        });
        
        canvas.on('mouse:dblclick', function(options) {
            try {
                console.log('Evento de duplo clique detectado:', options);
                
                if (!options.target) {
                    console.log('Nenhum objeto no alvo do duplo clique');
                    return;
                }
                
                const obj = options.target;
                console.log('Duplo clique em objeto do tipo:', obj.type);
                
                // Garante que o objeto esteja selecionado
                canvas.setActiveObject(obj);
                canvas.renderAll();
                
                // Mostra o menu de configuração apropriado
                showConfigMenuForObject(obj, 'dblclick');
            } catch (error) {
                console.error('Erro ao processar duplo clique:', error);
            }
        });
        
        // Adiciona um botão para fechar todos os menus
        document.addEventListener('keydown', function(e) {
            // Fecha todos os menus ao pressionar a tecla ESC
            if (e.key === 'Escape') {
                hideAllConfigMenus();
                console.log('Todos os menus fechados com a tecla ESC');
            }
        });
        
        // Adiciona um botão para fechar todos os menus ao clicar fora deles
        document.addEventListener('click', function(e) {
            // Verifica se o clique foi fora de qualquer menu
            const isClickInsideMenu = e.target.closest('.config-menu');
            const isClickOnButton = e.target.closest('button');
            
            // Se o clique não foi dentro de um menu nem em um botão, fecha todos os menus
            if (!isClickInsideMenu && !isClickOnButton) {
                hideAllConfigMenus();
            }
        });

        // Função para criar o menu de formas
        function createShapesMenu() {
            console.log('Criando menu de formas...');
            
            // Verifica se já existe um dropdown e remove se existir
            const existingDropdown = document.getElementById('shapesDropdown');
            if (existingDropdown) {
                existingDropdown.remove();
                console.log('Menu de formas existente removido');
            }
            
            // Criar o dropdown
            const shapesDropdown = document.createElement('div');
            shapesDropdown.id = 'shapesDropdown';
            shapesDropdown.style.display = 'none';
            shapesDropdown.style.position = 'absolute';
            shapesDropdown.style.zIndex = '1002';
            shapesDropdown.style.background = 'white';
            shapesDropdown.style.border = '1px solid #ccc';
            shapesDropdown.style.borderRadius = '4px';
            shapesDropdown.style.padding = '10px';
            shapesDropdown.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
            shapesDropdown.style.width = '260px';
            shapesDropdown.style.maxHeight = '400px';
            shapesDropdown.style.overflowY = 'auto';
            
            // Adicionar título para seção de formas básicas
            const basicShapesTitle = document.createElement('h3');
            basicShapesTitle.textContent = 'Formas Básicas';
            basicShapesTitle.style.margin = '5px 0';
            basicShapesTitle.style.padding = '0';
            basicShapesTitle.style.fontSize = '14px';
            basicShapesTitle.style.fontWeight = 'bold';
            basicShapesTitle.style.borderBottom = '1px solid #ddd';
            shapesDropdown.appendChild(basicShapesTitle);
            
            // Lista de formas básicas disponíveis
            const shapes = [
                {
                    name: 'Retângulo',
                    preview: '<svg viewBox="0 0 24 24" width="24" height="24"><rect x="2" y="4" width="20" height="16" fill="none" stroke="black" stroke-width="2"/></svg>',
                    action: () => {
                        const rect = new fabric.Rect({
                            left: 100,
                            top: 100,
                            width: 100,
                            height: 80,
                            fill: document.getElementById('colorPicker').value,
                            stroke: '#a3a3a3',
                            strokeWidth: 4
                        });
                        canvas.add(rect);
                        canvas.setActiveObject(rect);
                        document.getElementById('shapesDropdown').style.display = 'none';
                        
                        // Mostrar menu de configuração
                        hideAllConfigMenus();
                        document.getElementById('shapeConfigMenu').style.display = 'block';
                        updateShapeMenu(rect);
                    }
                },
                {
                    name: 'Círculo',
                    preview: '<svg viewBox="0 0 24 24" width="24" height="24"><circle cx="12" cy="12" r="10" fill="none" stroke="black" stroke-width="2"/></svg>',
                    action: () => {
                        const circle = new fabric.Circle({
                            left: 100,
                            top: 100,
                            radius: 50,
                            fill: document.getElementById('colorPicker').value,
                            stroke: '#000000',
                            strokeWidth: 2
                        });
                        canvas.add(circle);
                        canvas.setActiveObject(circle);
                        document.getElementById('shapesDropdown').style.display = 'none';
                        
                        // Mostrar menu de configuração
                        hideAllConfigMenus();
                        document.getElementById('shapeConfigMenu').style.display = 'block';
                        updateShapeMenu(circle);
                    }
                },
                {
                    name: 'Triângulo',
                    preview: '<svg viewBox="0 0 24 24" width="24" height="24"><polygon points="12,2 22,22 2,22" fill="none" stroke="black" stroke-width="2"/></svg>',
                    action: () => {
                        const triangle = new fabric.Triangle({
                            left: 100,
                            top: 100,
                            width: 100,
                            height: 100,
                            fill: document.getElementById('colorPicker').value,
                            stroke: '#000000',
                            strokeWidth: 2
                        });
                        canvas.add(triangle);
                        canvas.setActiveObject(triangle);
                        document.getElementById('shapesDropdown').style.display = 'none';
                        
                        // Mostrar menu de configuração
                        hideAllConfigMenus();
                        document.getElementById('shapeConfigMenu').style.display = 'block';
                        updateShapeMenu(triangle);
                    }
                },
                {
                    name: 'Linha',
                    preview: '<svg viewBox="0 0 24 24" width="24" height="24"><line x1="2" y1="12" x2="22" y2="12" stroke="black" stroke-width="2"/></svg>',
                    action: () => {
                        const line = new fabric.Line([50, 100, 200, 100], {
                            stroke: document.getElementById('colorPicker').value,
                            strokeWidth: 5
                        });
                        canvas.add(line);
                        canvas.setActiveObject(line);
                        document.getElementById('shapesDropdown').style.display = 'none';
                        
                        // Mostrar menu de configuração
                        hideAllConfigMenus();
                        document.getElementById('shapeConfigMenu').style.display = 'block';
                        updateShapeMenu(line);
                    }
                },
                {
                    name: 'Elipse',
                    preview: '<svg viewBox="0 0 24 24" width="24" height="24"><ellipse cx="12" cy="12" rx="10" ry="6" fill="none" stroke="black" stroke-width="2"/></svg>',
                    action: () => {
                        const ellipse = new fabric.Ellipse({
                            left: 100,
                            top: 100,
                            rx: 50,
                            ry: 30,
                            fill: document.getElementById('colorPicker').value,
                            stroke: '#000000',
                            strokeWidth: 2
                        });
                        canvas.add(ellipse);
                        canvas.setActiveObject(ellipse);
                        document.getElementById('shapesDropdown').style.display = 'none';
                        
                        // Mostrar menu de configuração
                        hideAllConfigMenus();
                        document.getElementById('shapeConfigMenu').style.display = 'block';
                        updateShapeMenu(ellipse);
                    }
                }
            ];
            
            // Criar botões para cada forma
            shapes.forEach(shape => {
                const button = document.createElement('button');
                button.innerHTML = shape.preview + ' ' + shape.name;
                button.style.display = 'flex';
                button.style.alignItems = 'center';
                button.style.width = '100%';
                button.style.textAlign = 'left';
                button.style.margin = '5px 0';
                button.style.padding = '8px';
                button.style.border = '1px solid #ddd';
                button.style.background = 'white';
                button.style.cursor = 'pointer';
                button.style.borderRadius = '4px';
                
                button.addEventListener('mouseover', () => {
                    button.style.backgroundColor = '#f0f8ff';
                });
                
                button.addEventListener('mouseout', () => {
                    button.style.backgroundColor = 'white';
                });
                
                button.addEventListener('click', shape.action);
                
                shapesDropdown.appendChild(button);
            });
            
            // DEBUG: Verificar se o botão de formas está configurado corretamente
            console.log('Botão de formas:', document.getElementById('shapesButton'));
            
            // Adicionar título para seção de SVGs personalizados
            const customSvgTitle = document.createElement('h3');
            customSvgTitle.textContent = 'SVGs Personalizados';
            customSvgTitle.style.margin = '15px 0 5px 0';
            customSvgTitle.style.padding = '0';
            customSvgTitle.style.fontSize = '14px';
            customSvgTitle.style.fontWeight = 'bold';
            customSvgTitle.style.borderBottom = '1px solid #ddd';
            shapesDropdown.appendChild(customSvgTitle);
            
            // Criar container para SVGs personalizados
            const svgContainer = document.createElement('div');
            svgContainer.id = 'svgCustomContainer';
            svgContainer.style.display = 'flex';
            svgContainer.style.flexWrap = 'wrap';
            svgContainer.style.justifyContent = 'space-between';
            shapesDropdown.appendChild(svgContainer);
            
            // DEBUG: Adicionar um SVG estático para verificar se o container está funcionando
            const debugSvg = document.createElement('div');
            debugSvg.innerHTML = '<div style="width: 60px; height: 60px; border: 1px solid #ddd; border-radius: 4px; display: flex; align-items: center; justify-content: center; background: #f0f0f0; margin: 5px;">SVG Test</div>';
            svgContainer.appendChild(debugSvg);
            
            // Carregar SVGs da pasta
            console.log('Chamando função para carregar SVGs...');
            loadSvgsFromFolder(svgContainer);
            
            // Adicionar ao documento
            document.body.appendChild(shapesDropdown);
            console.log('Menu de formas criado com sucesso');
            
            // DEBUG: Verificar se o dropdown está no DOM
            console.log('Dropdown adicionado ao DOM:', document.getElementById('shapesDropdown'));
            
            // Verificar evento de click no botão de formas
            const shapesButton = document.getElementById('shapesButton');
            if (shapesButton) {
                console.log('Configurando evento de clique no botão de formas');
                // Remover event listeners anteriores
                const newButton = shapesButton.cloneNode(true);
                shapesButton.parentNode.replaceChild(newButton, shapesButton);
                
                // Adicionar novo event listener com log
                newButton.addEventListener('click', (e) => {
                    console.log('Botão de formas clicado!');
                    const dropdown = document.getElementById('shapesDropdown');
                    if (!dropdown) {
                        console.error('Dropdown não encontrado no DOM!');
                        return;
                    }
                    
                    // Alternar visibilidade do dropdown
                    if (dropdown.style.display === 'block') {
                        dropdown.style.display = 'none';
                        console.log('Menu de formas fechado');
                    } else {
                        // Posiciona o dropdown abaixo do botão
                        const buttonRect = e.target.closest('button').getBoundingClientRect();
                        dropdown.style.display = 'block';
                        dropdown.style.top = `${buttonRect.bottom + 5}px`;
                        dropdown.style.left = `${buttonRect.left}px`;
                        console.log('Menu de formas aberto em:', buttonRect.left, buttonRect.bottom + 5);
                        console.log('Estado atual do menu:', dropdown.style.display, dropdown.style.top, dropdown.style.left);
                        
                        // Garantir que o menu de formas tenha o z-index maior que outros elementos
                        dropdown.style.zIndex = '1002';
                    }
                });
            } else {
                console.error('Botão de formas não encontrado!');
            }
        }

        // Função para carregar SVGs da pasta "svg" e adicionar ao menu
        function loadSvgsFromFolder(container) {
            console.log('Simplificando carregamento de SVGs para depuração...');
            
            // SVGs inline para fins de teste
            const svgInlineList = [
                // Seta
                '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M5,12H19M19,12L13,6M19,12L13,18" fill="none" stroke="black" stroke-width="2" stroke-linecap="round"/></svg>',
                
                // Estrela
                '<svg viewBox="0 0 24 24" width="24" height="24"><polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26" fill="none" stroke="black" stroke-width="1.5"/></svg>',
                
                // Nuvem
                '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M5.5,15C3.57,15 2,13.43 2,11.5C2,9.57 3.57,8 5.5,8C5.89,8 6.26,8.07 6.6,8.21C7.22,6.36 9.08,5 11.25,5C13.96,5 16.19,7.1 16.46,9.73C17.37,10.04 18.1,10.73 18.51,11.61C19.44,11.13 20.56,11.53 21.04,12.46C21.53,13.38 21.13,14.5 20.21,14.99C19.33,15.45 18.28,15.06 17.77,14.21C17.46,14.32 17.13,14.38 16.78,14.38C15.28,14.38 14.02,13.21 13.89,11.75C13.3,10.95 12.69,10.85 12,10.85C10.5,10.85 9.27,12.05 9.25,13.5C9.25,13.5 9.25,13.5 9.25,13.5C9.25,14.05 9.4,14.56 9.67,15H5.5Z" fill="none" stroke="black" stroke-width="1.5"/></svg>',
                



                // Ícone de documento
                '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M14,2H6C4.9,2 4,2.9 4,4V20C4,21.1 4.9,22 6,22H18C19.1,22 20,21.1 20,20V8L14,2Z" fill="none" stroke="black" stroke-width="1.5"/><path d="M14,2V8H20" fill="none" stroke="black" stroke-width="1.5"/><line x1="16" y1="13" x2="8" y2="13" stroke="black" stroke-width="1.5"/><line x1="16" y1="17" x2="8" y2="17" stroke="black" stroke-width="1.5"/><line x1="10" y1="9" x2="8" y2="9" stroke="black" stroke-width="1.5"/></svg>',
                





                
                // Coração
                '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z" fill="none" stroke="black" stroke-width="1.5"/></svg>'
            ];
            
            console.log(`Adicionando ${svgInlineList.length} SVGs de teste...`);
            
            // Para cada SVG inline, criar um botão
            svgInlineList.forEach((svgInline, index) => {
                // Criar um botão para o SVG
                const button = document.createElement('button');
                
                // Definir o conteúdo do botão com o SVG
                button.innerHTML = `<div style="width: 45px; height: 45px; display: flex; align-items: center; justify-content: center; overflow: hidden;">${svgInline}</div>`;
                
                button.style.width = '60px';
                button.style.height = '60px';
                button.style.margin = '5px';
                button.style.padding = '3px';
                button.style.border = '1px solid #ddd';
                button.style.background = 'white';
                button.style.cursor = 'pointer';
                button.style.borderRadius = '4px';
                button.style.display = 'flex';
                button.style.alignItems = 'center';
                button.style.justifyContent = 'center';
                button.title = `SVG de teste ${index + 1}`;
                
                button.addEventListener('mouseover', () => {
                    button.style.backgroundColor = '#f0f8ff';
                });
                
                button.addEventListener('mouseout', () => {
                    button.style.backgroundColor = 'white';
                });
                
                // Adicionar ação ao clicar no botão
                button.addEventListener('click', () => {
                    console.log(`Adicionando SVG de teste ${index + 1}`);
                    
                    fabric.loadSVGFromString(svgInline, function(objects, options) {
                        try {
                            // Criar um grupo com todos os objetos do SVG
                            const svgGroup = fabric.util.groupSVGElements(objects, options);
                            
                            // Ajustar o tamanho
                            const maxSize = 100;
                            if (svgGroup.width > maxSize || svgGroup.height > maxSize) {
                                const scale = maxSize / Math.max(svgGroup.width, svgGroup.height);
                                svgGroup.scale(scale);
                            }
                            
                            // Posicionar no centro da tela
                            svgGroup.set({
                                left: canvas.width / 2,
                                top: canvas.height / 2,
                                originX: 'center',
                                originY: 'center',
                                fill: document.getElementById('colorPicker').value
                            });
                            
                            // Adicionar ao canvas
                            canvas.add(svgGroup);
                            canvas.setActiveObject(svgGroup);
                            canvas.renderAll();
                            
                            // Fechar o menu
                            document.getElementById('shapesDropdown').style.display = 'none';
                            
                            // Mostrar menu de configuração
                            hideAllConfigMenus();
                            document.getElementById('shapeConfigMenu').style.display = 'block';
                            updateShapeMenu(svgGroup);
                            
                            console.log('SVG adicionado ao canvas com sucesso');
                        } catch (error) {
                            console.error('Erro ao processar SVG:', error);
                            alert('Erro ao adicionar SVG: ' + error.message);
                        }
                    });
                });
                
                // Adicionar o botão ao container
                container.appendChild(button);
            });
            
            console.log('SVGs de teste adicionados com sucesso!');
            
            // Mensagem informativa
            const infoMsg = document.createElement('div');
            infoMsg.textContent = 'Em breve mais imagens e uma versão futura.';
            infoMsg.style.padding = '10px';
            infoMsg.style.color = '#666';
            infoMsg.style.fontSize = '12px';
            infoMsg.style.fontStyle = 'italic';
            infoMsg.style.marginTop = '10px';
            container.appendChild(infoMsg);
        }

        // Configuração do menu de imagem
        document.getElementById('imageOpacity').addEventListener('input', (e) => {
            try {
                const value = e.target.value;
                document.getElementById('imageOpacityValue').textContent = value;
                const activeObject = canvas.getActiveObject();
                if (activeObject && activeObject.type === 'image') {
                    activeObject.set('opacity', parseInt(value) / 100);
                    canvas.renderAll();
                    console.log('Opacidade da imagem atualizada para', parseInt(value) / 100);
                }
            } catch (error) {
                console.error('Erro ao atualizar opacidade da imagem:', error);
            }
        });

        document.getElementById('imageBorderWidth').addEventListener('input', (e) => {
            try {
                const value = e.target.value;
                document.getElementById('imageBorderWidthValue').textContent = value;
                const activeObject = canvas.getActiveObject();
                if (activeObject && activeObject.type === 'image') {
                    activeObject.set('strokeWidth', parseInt(value));
                    canvas.renderAll();
                    console.log('Largura da borda da imagem atualizada para', value);
                }
            } catch (error) {
                console.error('Erro ao atualizar largura da borda da imagem:', error);
            }
        });

        document.getElementById('imageBorderColor').addEventListener('input', (e) => {
            try {
                const activeObject = canvas.getActiveObject();
                if (activeObject && activeObject.type === 'image') {
                    activeObject.set('stroke', e.target.value);
                    canvas.renderAll();
                    console.log('Cor da borda da imagem atualizada para', e.target.value);
                }
            } catch (error) {
                console.error('Erro ao atualizar cor da borda da imagem:', error);
            }
        });

        // Função unificada para mostrar o menu de configuração de acordo com o tipo de objeto
        function showConfigMenuForObject(obj, eventType) {
            try {
                console.log(`Mostrando menu de configuração para ${obj.type} após evento ${eventType}`);
                
                // Primeiro esconde todos os menus
                hideAllConfigMenus();
                
                // Depois determina qual menu deve ser exibido baseado no tipo do objeto
                if (obj.type === 'i-text' || obj.type === 'text') {
                    const menu = document.getElementById('textEditMenu');
                    menu.style.display = 'block';
                    menu.style.zIndex = '1001'; // Garante alta visibilidade
                    updateTextMenu(obj);
                    console.log(`Menu de texto exibido após ${eventType}`);
                } else if (obj.type === 'path') {
                    const menu = document.getElementById('pathEditMenu');
                    menu.style.display = 'block';
                    menu.style.zIndex = '1001';
                    updatePathMenu(obj);
                    console.log(`Menu de caminho exibido após ${eventType}`);
                } else if (obj.type === 'image') {
                    showImageMenu(obj);
                    console.log(`Menu de imagem exibido após ${eventType}`);
                } else {
                    const menu = document.getElementById('shapeConfigMenu');
                    menu.style.display = 'block';
                    menu.style.zIndex = '1001';
                    updateShapeMenu(obj);
                    console.log(`Menu de forma exibido após ${eventType}`);
                }
                
                // Verifica se o menu está realmente visível
                setTimeout(() => {
                    const menuTypes = {
                        'i-text': 'textEditMenu',
                        'text': 'textEditMenu',
                        'path': 'pathEditMenu',
                        'image': 'imageMenu',
                        'rect': 'shapeConfigMenu',
                        'circle': 'shapeConfigMenu',
                        'triangle': 'shapeConfigMenu',
                        'line': 'shapeConfigMenu'
                    };
                    
                    const menuId = menuTypes[obj.type] || 'shapeConfigMenu';
                    const menu = document.getElementById(menuId);
                    
                    if (menu) {
                        console.log(`Status final do menu ${menuId}: display=${menu.style.display}, zIndex=${menu.style.zIndex}`);
                        
                        // Se o menu não estiver visível, tenta forçar a exibição
                        if (menu.style.display !== 'block') {
                            console.warn(`Menu ${menuId} não está visível, forçando exibição...`);
                            menu.style.display = 'block';
                            menu.style.zIndex = '1001';
                        }
                    } else {
                        console.error(`Menu ${menuId} não encontrado no DOM!`);
                    }
                }, 100);
            } catch (error) {
                console.error('Erro ao mostrar menu de configuração:', error);
            }
        }

        // Nova função para configurar todos os event listeners do canvas
        function setupCanvasEventListeners() {
            try {
                console.log('Configurando event listeners do canvas...');
                
                // Configuração global para todos os objetos usarem seleção por pixel
                fabric.Object.prototype.perPixelTargetFind = true;
                fabric.Object.prototype.targetFindTolerance = 4;
                
                console.log('Seleção por pixel configurada para todos os objetos');
                
                // Listener para seleção criada
                canvas.on('selection:created', function(options) {
                    try {
                        console.log('Seleção criada:', options);
                        const obj = canvas.getActiveObject();
                        if (!obj) return;
                        
                        showConfigMenuForObject(obj, 'selection:created');
                    } catch (error) {
                        console.error('Erro ao processar seleção criada:', error);
                    }
                });
                
                // Listener para seleção atualizada
                canvas.on('selection:updated', function(options) {
                    try {
                        console.log('Seleção atualizada:', options);
                        const obj = canvas.getActiveObject();
                        if (!obj) return;
                        
                        showConfigMenuForObject(obj, 'selection:updated');
                    } catch (error) {
                        console.error('Erro ao processar seleção atualizada:', error);
                    }
                });
                
                // Listener para adição de objetos (para configurar propriedades de seleção)
                canvas.on('object:added', function(options) {
                    try {
                        if (!options.target) return;
                        
                        const obj = options.target;
                        console.log('Objeto adicionado:', obj.type);
                        
                        // Garantir que todos os objetos usem seleção por pixel
                        obj.perPixelTargetFind = true;
                        obj.targetFindTolerance = 4;
                        
                        // Para objetos sem preenchimento, ajustar a largura da borda para ser selecionável
                        if (obj.fill === 'transparent' || !obj.fill) {
                            obj.strokeWidth = Math.max(2, obj.strokeWidth || 0);
                        }
                        
                        console.log('Configurações de seleção aplicadas ao novo objeto');
                    } catch (error) {
                        console.error('Erro ao configurar novo objeto:', error);
                    }
                });
                
                // Listener para seleção removida
                canvas.on('selection:cleared', function() {
                    try {
                        console.log('Seleção removida');
                        hideAllConfigMenus();
                    } catch (error) {
                        console.error('Erro ao processar remoção de seleção:', error);
                    }
                });
                
                // Listener para duplo clique - IMPORTANTE: este é o evento que deve mostrar o menu de configuração
                canvas.on('mouse:dblclick', function(options) {
                    try {
                        console.log('Evento de duplo clique detectado:', options);
                        
                        if (!options.target) {
                            console.log('Nenhum objeto no alvo do duplo clique');
                            return;
                        }
                        
                        const obj = options.target;
                        console.log('Duplo clique em objeto do tipo:', obj.type);
                        
                        // Garante que o objeto esteja selecionado
                        canvas.setActiveObject(obj);
                        canvas.renderAll();
                        
                        // Mostra o menu de configuração apropriado
                        showConfigMenuForObject(obj, 'dblclick');
                    } catch (error) {
                        console.error('Erro ao processar duplo clique:', error);
                    }
                });
                
                console.log('Event listeners do canvas configurados com sucesso');
            } catch (error) {
                console.error('Erro ao configurar event listeners do canvas:', error);
            }
        }

        // Funções para atualizar os valores dos menus
        function updateTextMenu(textObj) {
            try {
                console.log('Atualizando menu de texto para:', textObj);
                document.getElementById('fontFamily').value = textObj.fontFamily || 'Arial';
                document.getElementById('fontSize').value = textObj.fontSize || 20;
                document.getElementById('fontSizeValue').textContent = textObj.fontSize || 20;
                document.getElementById('textColor').value = textObj.fill || '#000000';
                document.getElementById('textBgColor').value = textObj.backgroundColor || '#ffffff';
                document.getElementById('textOpacity').value = (textObj.opacity || 1) * 100;
                document.getElementById('textOpacityValue').textContent = Math.round((textObj.opacity || 1) * 100);
                console.log('Menu de texto atualizado com sucesso');
            } catch (error) {
                console.error('Erro ao atualizar menu de texto:', error);
            }
        }

        function updateShapeMenu(shapeObj) {
            try {
                console.log('Atualizando menu de forma para:', shapeObj);
                document.getElementById('shapeStrokeColor').value = shapeObj.stroke || '#000000';
                document.getElementById('shapeStrokeWidth').value = shapeObj.strokeWidth || 2;
                document.getElementById('shapeStrokeWidthValue').textContent = shapeObj.strokeWidth || 2;
                document.getElementById('shapeFillColor').value = shapeObj.fill || '#ffffff';
                document.getElementById('shapeFillToggle').checked = shapeObj.fill !== 'transparent';
                document.getElementById('shapeOpacity').value = (shapeObj.opacity || 1) * 100;
                document.getElementById('shapeOpacityValue').textContent = Math.round((shapeObj.opacity || 1) * 100);
                console.log('Menu de forma atualizado com sucesso');
            } catch (error) {
                console.error('Erro ao atualizar menu de forma:', error);
            }
        }

        function updatePathMenu(pathObj) {
            try {
                console.log('Atualizando menu de caminho para:', pathObj);
                document.getElementById('pathStrokeWidth').value = pathObj.strokeWidth || 5;
                document.getElementById('pathStrokeWidthValue').textContent = pathObj.strokeWidth || 5;
                document.getElementById('pathStrokeColor').value = pathObj.stroke || '#000000';
                document.getElementById('pathOpacity').value = (pathObj.opacity || 1) * 100;
                document.getElementById('pathOpacityValue').textContent = Math.round((pathObj.opacity || 1) * 100);
                console.log('Menu de caminho atualizado com sucesso');
            } catch (error) {
                console.error('Erro ao atualizar menu de caminho:', error);
            }
        }
        
        // Funções para salvar e carregar o projeto completo
        
        // Salvar todo o projeto em um arquivo local
        document.getElementById('saveProjectButton').addEventListener('click', function() {
            try {
                console.log('Salvando projeto...');
                
                // Capturar o estado atual do mosaico
                const mosaicState = captureMosaicState();
                
                // Capturar o estado atual do canvas
                const canvasState = captureCanvasState();
                
                // Criar o objeto completo do projeto
                const projectData = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    mosaico: mosaicState,
                    canvas: canvasState
                };
                
                // Converter para JSON
                const jsonData = JSON.stringify(projectData, null, 2);
                
                // Criar um Blob e um link de download
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // Criar um link para download e clicar nele
                const link = document.createElement('a');
                link.href = url;
                link.download = `projeto_${formatDate(new Date())}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                console.log('Projeto salvo com sucesso!');
            } catch (error) {
                console.error('Erro ao salvar o projeto:', error);
                alert('Erro ao salvar o projeto. Consulte o console para mais detalhes.');
            }
        });
        
        // Carregar o projeto de um arquivo local
        document.getElementById('loadProjectButton').addEventListener('click', function() {
            document.getElementById('loadProjectFile').click();
        });
        
        document.getElementById('loadProjectFile').addEventListener('change', function(event) {
            try {
                const file = event.target.files[0];
                if (!file) return;
                
                console.log('Carregando projeto do arquivo:', file.name);
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const projectData = JSON.parse(e.target.result);
                        
                        // Verificar a versão do arquivo
                        if (!projectData.version) {
                            throw new Error('Formato de arquivo inválido');
                        }
                        
                        console.log('Dados do projeto carregados:', projectData);
                        
                        // Restaurar o estado do mosaico
                        if (projectData.mosaico) {
                            restoreMosaicState(projectData.mosaico);
                        }
                        
                        // Restaurar o estado do canvas
                        if (projectData.canvas) {
                            // Mudar para a aba do editor para garantir que o canvas está inicializado
                            document.querySelector('.tab[data-tab="editor"]').click();
                            
                            // Esperar um pouco para o canvas inicializar
                            setTimeout(() => {
                                restoreCanvasState(projectData.canvas);
                            }, 300);
                        }
                        
                        console.log('Projeto carregado com sucesso!');
                    } catch (error) {
                        console.error('Erro ao processar o arquivo do projeto:', error);
                        alert('Erro ao processar o arquivo do projeto. Verifique se o arquivo é válido.');
                    }
                };
                
                reader.readAsText(file);
            } catch (error) {
                console.error('Erro ao carregar o projeto:', error);
                alert('Erro ao carregar o projeto. Consulte o console para mais detalhes.');
            }
            
            // Limpar o input para permitir selecionar o mesmo arquivo novamente
            this.value = '';
        });
        
        // Função para formatar a data para o nome do arquivo
        function formatDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            
            return `${year}-${month}-${day}_${hours}-${minutes}`;
        }
        
        // Função para capturar o estado atual do mosaico
        function captureMosaicState() {
            try {
                // Obter todas as imagens do grid
                const gridItems = document.querySelectorAll('.grid-item');
                const itemsData = [];
                
                gridItems.forEach((item, index) => {
                    const img = item.querySelector('img');
                    
                    if (img) {
                        itemsData.push({
                            id: index,
                            src: img.src,
                            width: item.style.width,
                            height: img.offsetHeight,
                            left: item.offsetLeft,
                            top: item.offsetTop,
                            selected: item.classList.contains('selected'),
                            fixed: item.classList.contains('is-stamped'),
                            borderRadius: item.style.borderRadius,
                            scale: item.getAttribute('data-scale') || '100'
                        });
                    }
                });
                
                // Capturar configurações do mosaico
                const mosaicSettings = {
                    imageSize: document.getElementById('imageSize').value,
                    imageGap: document.getElementById('imageGap').value,
                    imageBorderRadius: document.getElementById('imageBorderRadius').value,
                    canvasWidth: document.getElementById('canvasWidth').value
                };
                
                return {
                    items: itemsData,
                    settings: mosaicSettings
                };
            } catch (error) {
                console.error('Erro ao capturar estado do mosaico:', error);
                throw error;
            }
        }
        
        // Função para capturar o estado atual do canvas
        function captureCanvasState() {
            try {
                if (!canvas) {
                    console.warn('Canvas não inicializado, não há estado para capturar');
                    return null;
                }
                
                // Capturar configurações do canvas
                const canvasSettings = {
                    width: canvas.width,
                    height: canvas.height,
                    backgroundColor: canvas.backgroundColor
                };
                
                // Capturar a imagem de fundo
                let backgroundImage = null;
                if (canvas.backgroundImage) {
                    if (typeof canvas.backgroundImage.toObject === 'function') {
                        backgroundImage = canvas.backgroundImage.toObject();
                    } else {
                        backgroundImage = {
                            src: canvas.backgroundImage.src,
                            scaleX: canvas.backgroundImage.scaleX,
                            scaleY: canvas.backgroundImage.scaleY
                        };
                    }
                }
                
                // Capturar todos os objetos do canvas
                const objects = canvas.getObjects().map(obj => {
                    // Convertemos para objeto e excluímos referências circulares
                    return obj.toObject(['id', 'name', 'customType']);
                });
                
                return {
                    settings: canvasSettings,
                    backgroundImage: backgroundImage,
                    objects: objects
                };
            } catch (error) {
                console.error('Erro ao capturar estado do canvas:', error);
                throw error;
            }
        }
        
        // Função para restaurar o estado do mosaico
        function restoreMosaicState(mosaicState) {
            try {
                console.log('Restaurando estado do mosaico...');
                
                // Limpar o grid atual
                const grid = document.querySelector('.grid');
                grid.innerHTML = '';
                
                // Restaurar configurações
                if (mosaicState.settings) {
                    const settings = mosaicState.settings;
                    
                    document.getElementById('imageSize').value = settings.imageSize;
                    document.getElementById('imageSizeValue').textContent = settings.imageSize;
                    
                    document.getElementById('imageGap').value = settings.imageGap;
                    document.getElementById('imageGapValue').textContent = settings.imageGap;
                    pckry.options.gutter = parseInt(settings.imageGap);
                    
                    document.getElementById('imageBorderRadius').value = settings.imageBorderRadius;
                    document.getElementById('imageBorderRadiusValue').textContent = settings.imageBorderRadius;
                    
                    document.getElementById('canvasWidth').value = settings.canvasWidth;
                    document.getElementById('canvasWidthValue').textContent = settings.canvasWidth;
                    document.querySelector('.grid').style.maxWidth = `${settings.canvasWidth}px`;
                }
                
                // Restaurar itens
                const promises = [];
                if (mosaicState.items && mosaicState.items.length > 0) {
                    mosaicState.items.forEach(itemData => {
                        promises.push(createGridItemFromData(itemData, grid));
                    });
                }
                
                // Aguardar todas as imagens carregarem e então reposicionar
                Promise.all(promises).then(() => {
                    pckry.layout();
                    // Reinicializa o mosaico para garantir que todos os itens sejam arrastáveis
                    initMosaico();
                    console.log('Estado do mosaico restaurado com sucesso!');
                });
            } catch (error) {
                console.error('Erro ao restaurar estado do mosaico:', error);
                throw error;
            }
        }
        
        // Criar um item do grid a partir dos dados
        function createGridItemFromData(itemData, grid) {
            return new Promise((resolve, reject) => {
                try {
                    const div = document.createElement('div');
                    div.className = 'grid-item';
                    
                    // Aplicar estilo
                    div.style.width = itemData.width;
                    div.style.borderRadius = itemData.borderRadius;
                    
                    if (itemData.selected) {
                        div.classList.add('selected');
                    }
                    
                    if (itemData.fixed) {
                        div.classList.add('is-stamped');
                    }
                    
                    div.setAttribute('data-scale', itemData.scale);
                    div.setAttribute('data-original-width', parseInt(itemData.width));
                    
                    // Criar imagem
                    const img = document.createElement('img');
                    img.src = itemData.src;
                    
                    // Adicionar a imagem ao item
                    div.appendChild(img);
                    grid.appendChild(div);
                    
                    // Ao carregar a imagem, adicionar ao packers
                    img.onload = () => {
                        pckry.appended(div);
                        
                        // Configurar os controles do item
                        setupItemControls(div);
                        resolve();
                    };
                    
                    img.onerror = () => {
                        console.error('Erro ao carregar imagem:', itemData.src);
                        // Mesmo com erro, resolvemos a promessa para continuar
                        resolve();
                    };
                } catch (error) {
                    console.error('Erro ao criar item do grid:', error);
                    // Mesmo com erro, resolvemos a promessa para continuar
                    resolve();
                }
            });
        }
        
        // Função para tornar um item específico arrastável
        function makeItemDraggable(item) {
            // Verifica o modo atual
            const isDashboardMode = document.getElementById('layoutModeToggle')?.checked || false;
            const grid = document.querySelector('.grid');
            
            // Remove any existing draggability first
            const existingDraggie = Draggabilly.data(item);
            if (existingDraggie) {
                existingDraggie.destroy();
                item.classList.remove('is-draggable');
            }
            
            // Cria uma nova instância do Draggabilly para o item
            const draggie = new Draggabilly(item, {
                containment: grid
            });
            
            // Vincula os eventos do Draggabilly ao Packery
            pckry.bindDraggabillyEvents(draggie);
            item.classList.add('is-draggable');
            
            // Evento de início de arrasto
            draggie.on('dragStart', function() {
                item.classList.add('is-dragging');
                console.log('Iniciando arrasto de item');
            });
            
            // Evento de fim de arrasto
            draggie.on('dragEnd', function() {
                item.classList.remove('is-dragging');
                console.log('Finalizando arrasto de item');
                if (!isDashboardMode) {
                    // Reposiciona os itens após o arrasto no modo grid
                    pckry.layout();
                } else {
                    // Ajusta o item na posição mais próxima no modo dashboard
                    pckry.fit(item);
                }
            });
        }
        
        // Função para restaurar o estado do canvas
        function restoreCanvasState(canvasState) {
            try {
                if (!canvas) {
                    console.error('Canvas não inicializado, não é possível restaurar o estado');
                    return;
                }
                
                console.log('Restaurando estado do canvas...');
                
                // Limpar o canvas primeiro
                canvas.clear();
                
                // Restaurar configurações
                if (canvasState.settings) {
                    canvas.setWidth(canvasState.settings.width);
                    canvas.setHeight(canvasState.settings.height);
                    canvas.setBackgroundColor(canvasState.settings.backgroundColor, canvas.renderAll.bind(canvas));
                }
                
                // Restaurar imagem de fundo
                if (canvasState.backgroundImage && canvasState.backgroundImage.src) {
                    fabric.Image.fromURL(canvasState.backgroundImage.src, (img) => {
                        canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), {
                            scaleX: canvasState.backgroundImage.scaleX,
                            scaleY: canvasState.backgroundImage.scaleY,
                            originX: 'left',
                            originY: 'top'
                        });
                    });
                }
                
                // Restaurar objetos
                if (canvasState.objects && canvasState.objects.length > 0) {
                    canvasState.objects.forEach(objData => {
                        // Processa cada objeto com base no tipo
                        // É necessário chamar a função de criação correspondente para cada tipo
                        if (objData.type === 'rect') {
                            restoreRect(objData);
                        } else if (objData.type === 'circle') {
                            restoreCircle(objData);
                        } else if (objData.type === 'triangle') {
                            restoreTriangle(objData);
                        } else if (objData.type === 'line') {
                            restoreLine(objData);
                        } else if (objData.type === 'path') {
                            restorePath(objData);
                        } else if (objData.type === 'i-text' || objData.type === 'text') {
                            restoreText(objData);
                        } else if (objData.type === 'image') {
                            restoreImage(objData);
                        } else {
                            console.warn('Tipo de objeto não reconhecido:', objData.type);
                        }
                    });
                }
                
                console.log('Estado do canvas restaurado com sucesso!');
            } catch (error) {
                console.error('Erro ao restaurar estado do canvas:', error);
                throw error;
            }
        }
        
        // Funções auxiliares para restaurar cada tipo de objeto
        function restoreRect(objData) {
            const rect = new fabric.Rect(objData);
            canvas.add(rect);
        }
        
        function restoreCircle(objData) {
            const circle = new fabric.Circle(objData);
            canvas.add(circle);
        }
        
        function restoreTriangle(objData) {
            const triangle = new fabric.Triangle(objData);
            canvas.add(triangle);
        }
        
        function restoreLine(objData) {
            const line = new fabric.Line(objData.points || [objData.x1, objData.y1, objData.x2, objData.y2], objData);
            canvas.add(line);
        }
        
        function restorePath(objData) {
            const path = new fabric.Path(objData.path, objData);
            canvas.add(path);
        }
        
        function restoreText(objData) {
            const textOptions = Object.assign({}, objData);
            const text = new fabric.IText(objData.text, textOptions);
            canvas.add(text);
        }
        
        function restoreImage(objData) {
            // Para imagens, precisamos carregar a partir da URL
            if (objData.src) {
                fabric.Image.fromURL(objData.src, (img) => {
                    // Aplicar todas as outras propriedades
                    Object.keys(objData).forEach(key => {
                        if (key !== 'src' && key !== 'type') {
                            img[key] = objData[key];
                        }
                    });
                    
                    canvas.add(img);
                    canvas.renderAll();
                });
            }
        }

        // Configuração do botões de salvar e carregar projeto na inicialização
        document.addEventListener('DOMContentLoaded', function() {
            // Esperar o canvas ser inicializado
            setTimeout(function() {
                // Configurar botão de salvar projeto
                const saveProjectButton = document.getElementById('saveProjectButton');
                if (saveProjectButton) {
                    saveProjectButton.addEventListener('click', saveProject);
                    console.log('Botão de salvar projeto configurado');
                }
                
                // Configurar botão de carregar projeto
                const loadProjectButton = document.getElementById('loadProjectButton');
                if (loadProjectButton) {
                    loadProjectButton.addEventListener('click', function() {
                        // Input escondido para carregar arquivo
                        let fileInput = document.getElementById('projectFileInput');
                        if (!fileInput) {
                            fileInput = document.createElement('input');
                            fileInput.type = 'file';
                            fileInput.id = 'projectFileInput';
                            fileInput.accept = '.json';
                            fileInput.style.display = 'none';
                            fileInput.addEventListener('change', loadProject);
                            document.body.appendChild(fileInput);
                        }
                        fileInput.click();
                    });
                    console.log('Botão de carregar projeto configurado');
                }
            }, 1000); // Delay para garantir que o canvas esteja pronto
        });
        
        // Função para salvar o projeto atual em um arquivo JSON
        function saveProject() {
            try {
                console.log('Salvando projeto...');
                
                // Obter o JSON do canvas com todas as propriedades
                const canvasJSON = canvas.toJSON(['id', 'selectable', 'name']);
                
                // Criar um objeto de projeto com metadados
                const projeto = {
                    version: '1.0',
                    canvasData: canvasJSON,
                    canvasProps: {
                        width: canvas.width,
                        height: canvas.height,
                        backgroundColor: canvas.backgroundColor
                    },
                    timestamp: new Date().toISOString()
                };
                
                // Converter para string JSON
                const jsonStr = JSON.stringify(projeto, null, 2);
                
                // Criar um blob e fazer download
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `canvas-projeto-${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                console.log('Projeto salvo com sucesso!');
                alert('Projeto salvo com sucesso!');
            } catch (error) {
                console.error('Erro ao salvar projeto:', error);
                alert('Erro ao salvar projeto: ' + error.message);
            }
        }
        
        // Função para carregar projeto a partir de arquivo JSON
        function loadProject(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }
            
            console.log('Carregando projeto do arquivo:', file.name);
            
            // Confirmar com o usuário
            if (!confirm('Isso substituirá todo o conteúdo atual do canvas. Deseja continuar?')) {
                event.target.value = '';
                return;
            }
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const projeto = JSON.parse(e.target.result);
                    
                    // Verificar se é um arquivo de projeto válido
                    if (!projeto.canvasData) {
                        throw new Error('Arquivo de projeto inválido');
                    }
                    
                    // Limpar o canvas atual
                    canvas.clear();
                    
                    // Configurar propriedades do canvas
                    if (projeto.canvasProps) {
                        canvas.setWidth(projeto.canvasProps.width);
                        canvas.setHeight(projeto.canvasProps.height);
                        canvas.setBackgroundColor(
                            projeto.canvasProps.backgroundColor, 
                            canvas.renderAll.bind(canvas)
                        );
                    }
                    
                    // Carregar objetos do canvas
                    canvas.loadFromJSON(projeto.canvasData, function() {
                        canvas.renderAll();
                        console.log('Projeto carregado com sucesso!');
                        alert('Projeto carregado com sucesso!');
                    });
                    
                } catch (error) {
                    console.error('Erro ao processar arquivo JSON:', error);
                    alert('Erro ao carregar projeto: O arquivo selecionado não é um projeto válido.');
                }
            };
            
            reader.onerror = function() {
                console.error('Erro ao ler o arquivo');
                alert('Erro ao ler o arquivo. Por favor, tente novamente.');
            };
            
            reader.readAsText(file);
            event.target.value = ''; // Limpa o input para permitir selecionar o mesmo arquivo novamente
        }

        // Adicionar event listeners para salvar e carregar projeto na inicialização do canvas
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(function() {
                // Botão para salvar projeto como JSON
                const saveProjectButton = document.getElementById('saveProjectJSON');
                if (saveProjectButton) {
                    saveProjectButton.addEventListener('click', saveProjectAsJSON);
                    console.log('Botão de salvar projeto configurado');
                }
                
                // Botão para carregar projeto de JSON
                const loadProjectButton = document.getElementById('loadProjectJSON');
                if (loadProjectButton) {
                    loadProjectButton.addEventListener('click', function() {
                        const fileInput = document.createElement('input');
                        fileInput.type = 'file';
                        fileInput.accept = '.json';
                        fileInput.style.display = 'none';
                        document.body.appendChild(fileInput);
                        
                        fileInput.onchange = function(e) {
                            loadProjectFromJSON(e);
                            document.body.removeChild(fileInput);
                        };
                        
                        fileInput.click();
                    });
                    console.log('Botão de carregar projeto configurado');
                }
            }, 1000); // Esperar 1 segundo para garantir que o canvas está inicializado
        });
        
        // Função para salvar o projeto como arquivo JSON
        function saveProjectAsJSON() {
            try {
                console.log('Salvando projeto como JSON... (função direta)');
                
                if (!canvas) {
                    alert('Canvas não está disponível!');
                    return;
                }
                
                // Obtém o JSON do canvas
                const canvasJSON = canvas.toJSON(['id', 'selectable', 'name']);
                
                // Criar um objeto com informações do projeto
                const projeto = {
                    version: '1.0',
                    date: new Date().toISOString(),
                    canvasData: canvasJSON,
                    properties: {
                        width: canvas.width,
                        height: canvas.height,
                        backgroundColor: canvas.backgroundColor
                    }
                };
                
                // Converter para string JSON formatada
                const jsonString = JSON.stringify(projeto, null, 2);
                
                // Criar o blob e fazer download
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const fileName = `canvas-projeto-${new Date().toISOString().slice(0, 10)}.json`;
                
                const link = document.createElement('a');
                link.href = url;
                link.download = fileName;
                link.style.display = 'none';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                console.log('Projeto salvo com sucesso!');
                alert(`Projeto salvo com sucesso como ${fileName}`);
                
            } catch (error) {
                console.error('Erro ao salvar projeto:', error);
                alert('Erro ao salvar projeto: ' + error.message);
            }
        }
        
        // Função para carregar projeto de um arquivo JSON
        function loadProjectFromJSON(event) {
            try {
                console.log('Função loadProjectFromJSON chamada!', event);
                
                const file = event.target.files[0];
                if (!file) {
                    console.log('Nenhum arquivo selecionado');
                    return;
                }
                
                console.log('Carregando projeto do arquivo:', file.name);
                
                if (!confirm('Isso substituirá todo o conteúdo atual do canvas. Deseja continuar?')) {
                    console.log('Operação cancelada pelo usuário');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        console.log('Arquivo carregado, analisando JSON...');
                        const data = JSON.parse(e.target.result);
                        console.log('Dados analisados:', data);
                        
                        // Verificar se o arquivo tem o formato esperado
                        if (!data.canvasData) {
                            throw new Error('Formato de arquivo inválido. Não foi encontrado o campo canvasData.');
                        }
                        
                        // Limpar o canvas
                        canvas.clear();
                        
                        // Configurar propriedades do canvas
                        if (data.properties) {
                            console.log('Configurando propriedades do canvas:', data.properties);
                            canvas.setWidth(data.properties.width || 1200);
                            canvas.setHeight(data.properties.height || 800);
                            canvas.setBackgroundColor(
                                data.properties.backgroundColor || '#ffffff',
                                canvas.renderAll.bind(canvas)
                            );
                        }
                        
                        // Carregar os objetos do canvas
                        console.log('Carregando objetos no canvas...');
                        canvas.loadFromJSON(data.canvasData, function() {
                            canvas.renderAll();
                            console.log('Projeto carregado com sucesso!');
                            alert('Projeto carregado com sucesso!');
                        });
                        
                    } catch (error) {
                        console.error('Erro ao processar arquivo JSON:', error);
                        alert('Erro ao carregar projeto: ' + error.message);
                    }
                };
                
                reader.onerror = function() {
                    console.error('Erro na leitura do arquivo');
                    alert('Erro na leitura do arquivo. Por favor, tente novamente.');
                };
                
                console.log('Iniciando leitura do arquivo...');
                reader.readAsText(file);
                
            } catch (error) {
                console.error('Erro ao carregar projeto:', error);
                alert('Erro ao carregar projeto: ' + error.message);
            }
        }
    </script>
    
    <!-- Script para garantir a configuração dos botões de salvar e carregar projeto -->
    <script>
        // Executa após a página estar completamente carregada
        window.onload = function() {
            console.log('Configurando botões de projeto diretamente via window.onload...');
            
            // Configurar botão de salvar projeto
            const saveProjectButton = document.getElementById('saveProjectJSON');
            if (saveProjectButton) {
                saveProjectButton.onclick = function() {
                    console.log('Botão saveProjectJSON clicado!');
                    if (typeof saveProjectAsJSON === 'function') {
                        saveProjectAsJSON();
                    } else {
                        alert('A função saveProjectAsJSON não está disponível!');
                        console.error('Função saveProjectAsJSON não está definida');
                    }
                };
                console.log('Botão de salvar projeto configurado diretamente');
            } else {
                console.error('Botão saveProjectJSON não encontrado!');
            }
            
            // Configurar botão de carregar projeto
            const loadProjectButton = document.getElementById('loadProjectJSON');
            if (loadProjectButton) {
                loadProjectButton.onclick = function() {
                    console.log('Botão loadProjectJSON clicado!');
                    
                    // Cria um input file temporário
                    let fileInput = document.getElementById('temp-file-input');
                    
                    // Se não existir, cria
                    if (!fileInput) {
                        fileInput = document.createElement('input');
                        fileInput.type = 'file';
                        fileInput.id = 'temp-file-input';
                        fileInput.accept = '.json';
                        fileInput.style.position = 'fixed';
                        fileInput.style.top = '-100px';
                        fileInput.style.left = '-100px';
                        document.body.appendChild(fileInput);
                    }
                    
                    // Configurar evento onchange
                    fileInput.onchange = function(e) {
                        console.log('Arquivo selecionado:', e);
                        
                        if (typeof loadProjectFromJSON === 'function') {
                            loadProjectFromJSON(e);
                        } else {
                            alert('A função loadProjectFromJSON não está disponível!');
                            console.error('Função loadProjectFromJSON não está definida');
                        }
                    };
                    
                    // Simular o clique no input
                    fileInput.click();
                };
                console.log('Botão de carregar projeto configurado diretamente');
            } else {
                console.error('Botão loadProjectJSON não encontrado!');
            }
        };
    </script>

    <!-- Código para configurar o evento de clique no botão de formas -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Garantir que o documento esteja totalmente carregado
            console.log('DOM carregado, configurando eventos...');
            
            // Configurar o botão de formas
            const shapesButton = document.getElementById('shapesButton');
            
            if (shapesButton) {
                console.log('Encontrado botão de formas, configurando evento...');
                
                // Remover listeners existentes
                const newShapesButton = shapesButton.cloneNode(true);
                shapesButton.parentNode.replaceChild(newShapesButton, shapesButton);
                
                // Adicionar novo evento
                newShapesButton.addEventListener('click', function(e) {
                    console.log('Botão de formas clicado!');
                    
                    // Usar o dropdown existente no HTML
                    const dropdown = document.getElementById('shapesDropdown');
                    
                    if (!dropdown) {
                        console.error('Menu de formas não encontrado!');
                        return;
                    }
                    
                    // Verificar o estado atual do SVG container
                    const svgContainer = document.getElementById('svgCustomContainer');
                    
                    // Se o container já existe, significa que já adicionamos SVGs antes
                    if (!svgContainer && dropdown.style.display !== 'block') {
                        console.log('Primeira vez abrindo o menu, vamos adicionar SVGs...');
                        
                        // Adicionar título para SVGs personalizados
                        const customTitle = document.createElement('h3');
                        customTitle.textContent = 'SVGs Personalizados';
                        customTitle.style.margin = '15px 0 5px 0';
                        customTitle.style.fontSize = '14px';
                        customTitle.style.fontWeight = 'bold';
                        customTitle.style.borderBottom = '1px solid #ddd';
                        dropdown.appendChild(customTitle);
                        
                        // Criar container para SVGs personalizados
                        const svgCustomContainer = document.createElement('div');
                        svgCustomContainer.id = 'svgCustomContainer';
                        svgCustomContainer.style.display = 'flex';
                        svgCustomContainer.style.flexWrap = 'wrap';
                        svgCustomContainer.style.justifyContent = 'space-between';
                        dropdown.appendChild(svgCustomContainer);
                        
                        // Adicionar SVGs de teste
                        addTestSvgs(svgCustomContainer);
                    }
                    
                    // Alternar visibilidade do dropdown
                    if (dropdown.style.display === 'block') {
                        dropdown.style.display = 'none';
                        console.log('Menu de formas fechado');
                    } else {
                        // Posiciona o dropdown abaixo do botão
                        const buttonRect = e.target.closest('button').getBoundingClientRect();
                        dropdown.style.display = 'block';
                        dropdown.style.position = 'absolute';
                        dropdown.style.top = `${buttonRect.bottom + 5}px`;
                        dropdown.style.left = `${buttonRect.left}px`;
                        dropdown.style.zIndex = '1002';
                        dropdown.style.background = 'white';
                        dropdown.style.border = '1px solid #ccc';
                        dropdown.style.borderRadius = '4px';
                        dropdown.style.padding = '10px';
                        dropdown.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
                        dropdown.style.width = '260px';
                        dropdown.style.maxHeight = '400px';
                        dropdown.style.overflowY = 'auto';
                        
                        console.log('Menu de formas aberto em:', buttonRect.left, buttonRect.bottom + 5);
                    }
                });
                
                console.log('Evento de clique configurado para o botão de formas');
            } else {
                console.error('Botão de formas não encontrado!');
            }
        });

        // Função para adicionar SVGs de teste
        function addTestSvgs(container) {
            console.log('Adicionando coleção completa de SVGs...');
            
            // Limpar o container existente
            container.innerHTML = '';
            
            // Categorias de SVGs para organização
            const svgCategories = [
                {
                    title: 'Setas Simples',
                    items: [
                        // Seta direita
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M5,12H19M19,12L13,6M19,12L13,18" fill="none" stroke="black" stroke-width="2" stroke-linecap="round"/></svg>',
                            title: 'Seta direita'
                        },
                        // Seta esquerda
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M19,12H5M5,12L11,6M5,12L11,18" fill="none" stroke="black" stroke-width="2" stroke-linecap="round"/></svg>',
                            title: 'Seta esquerda'
                        },
                        // Seta para cima
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M12,19V5M12,5L6,11M12,5L18,11" fill="none" stroke="black" stroke-width="2" stroke-linecap="round"/></svg>',
                            title: 'Seta para cima'
                        },
                        // Seta para baixo
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M12,5V19M12,19L6,13M12,19L18,13" fill="none" stroke="black" stroke-width="2" stroke-linecap="round"/></svg>',
                            title: 'Seta para baixo'
                        },
                        // Seta diagonal (canto superior direito)
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M6,18L18,6M18,6H10M18,6V14" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
                            title: 'Seta diagonal ↗'
                        },
                        // Seta diagonal (canto inferior direito)
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M6,6L18,18M18,18H10M18,18V10" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
                            title: 'Seta diagonal ↘'
                        }
                    ]
                },
                {
                    title: 'Setas Bidirecionais',
                    items: [
                        // Seta bidirecional horizontal
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M5,12H19M5,12L9,8M5,12L9,16M19,12L15,8M19,12L15,16" fill="none" stroke="black" stroke-width="2" stroke-linecap="round"/></svg>',
                            title: 'Bidirecional horizontal'
                        },
                        // Seta bidirecional vertical
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M12,5V19M12,5L8,9M12,5L16,9M12,19L8,15M12,19L16,15" fill="none" stroke="black" stroke-width="2" stroke-linecap="round"/></svg>',
                            title: 'Bidirecional vertical'
                        },
                        // Seta diagonal bidirecional
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M5,5L19,19M5,5L9,5M5,5L5,9M19,19L15,19M19,19L19,15" fill="none" stroke="black" stroke-width="2" stroke-linecap="round"/></svg>',
                            title: 'Bidirecional diagonal ↘'
                        },
                        // Seta diagonal inversa bidirecional
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M19,5L5,19M19,5L15,5M19,5L19,9M5,19L9,19M5,19L5,15" fill="none" stroke="black" stroke-width="2" stroke-linecap="round"/></svg>',
                            title: 'Bidirecional diagonal ↙'
                        },
                        // Seta dupla horizontal grande
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M3,12H21M3,12L7,8M3,12L7,16M21,12L17,8M21,12L17,16" fill="none" stroke="black" stroke-width="2" stroke-linecap="round"/></svg>',
                            title: 'Bidirecional larga'
                        },
                        // Seta quatro direções
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M12,5V19M12,5L8,9M12,5L16,9M12,19L8,15M12,19L16,15M5,12H19M5,12L9,8M5,12L9,16M19,12L15,8M19,12L15,16" fill="none" stroke="black" stroke-width="2" stroke-linecap="round"/></svg>',
                            title: 'Quatro direções'
                        }
                    ]
                },
                {
                    title: 'Setas Curvas',
                    items: [
                        // Curva simples com seta
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M4,18C4,10 10,4 18,4M18,4L14,6M18,4L16,8" fill="none" stroke="black" stroke-width="2" stroke-linecap="round"/></svg>',
                            title: 'Curva com seta'
                        },
                        // Curva simples bidirecional
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M4,18C4,10 10,4 18,4M18,4L14,6M18,4L16,8M4,18L8,16M4,18L6,14" fill="none" stroke="black" stroke-width="2" stroke-linecap="round"/></svg>',
                            title: 'Curva bidirecional'
                        },
                        // Curva em S
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M4,6C8,6 8,18 12,18S16,6 20,6" fill="none" stroke="black" stroke-width="2" stroke-linecap="round"/></svg>',
                            title: 'Curva em S'
                        },
                        // Curva em S com setas
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M4,6C8,6 8,18 12,18S16,6 20,6M4,6L7,4M4,6L7,8M20,6L17,4M20,6L17,8" fill="none" stroke="black" stroke-width="2" stroke-linecap="round"/></svg>',
                            title: 'Curva em S bidirectional'
                        },
                        // Arco 90 graus
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M20,4v12c0,2.2-1.8,4-4,4H4 M4,20l4-4 M4,20l4,4" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
                            title: 'Arco 90° com seta'
                        },
                        // Arco invertido
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M4,20V8c0-2.2,1.8-4,4-4h12 M20,4l-4,4 M20,4l-4-4" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
                            title: 'Arco 90° invertido'
                        }
                    ]
                },
                {
                    title: 'Setas Especiais',
                    items: [
                        // Seta dupla horizontal metade
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M12,4v16M12,4l-4,4M12,4l4,4" fill="none" stroke="black" stroke-width="2" stroke-linecap="round"/></svg>',
                            title: 'Seta para cima'
                        },
                        // Seta circular
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M19,8a7,7 0 1,0 -7,7 M12,15l3,-3 M12,15l3,3" fill="none" stroke="black" stroke-width="2" stroke-linecap="round"/></svg>',
                            title: 'Seta circular'
                        },
                        // Seta de retorno
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M20,8H8c-2.2,0-4,1.8-4,4s1.8,4,4,4h12 M15,5l3,3 M15,11l3-3" fill="none" stroke="black" stroke-width="2" stroke-linecap="round"/></svg>',
                            title: 'Seta de retorno'
                        },
                        // Seta de retorno invertida
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M4,8h12c2.2,0,4,1.8,4,4s-1.8,4-4,4H4 M9,5l-3,3 M9,11l-3-3" fill="none" stroke="black" stroke-width="2" stroke-linecap="round"/></svg>',
                            title: 'Seta de retorno invertida'
                        },
                        // Seta com loop
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M12,21c-4.4,0-8-3.6-8-8c0-4.4,3.6-8,8-8s8,3.6,8,8v1 M17,16l3,3 M17,16l3-3" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
                            title: 'Seta com loop'
                        },
                        // Seta para cima e para baixo
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M7,6l5,-5l5,5 M7,18l5,5l5,-5 M12,1v22" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
                            title: 'Seta vertical dupla'
                        }
                    ]
                },
                {
                    title: 'Setas da Pasta',
                    items: [
                        // Arrow-9 - Selecionado da pasta
                        {
                            svg: '<svg viewBox="0 0 534 534" width="24" height="24"><path d="M402.586 185.369C394.539 185.557 387.117 185.551 379.721 185.992C373.41 186.368 367.138 187.391 360.827 187.81C359.538 187.895 358.154 186.569 356.814 185.894C358.085 184.868 359.297 183.044 360.636 182.946C370.653 182.209 374.914 173.935 380.925 167.933C386.914 161.952 392.711 155.731 399.194 150.338C400.441 149.3 405.126 150.833 407.102 152.508C416.269 160.276 425.091 168.457 433.9 176.638C435.293 177.931 435.984 179.979 437 181.679C435.348 182.059 433.714 182.628 432.041 182.787C422.441 183.702 412.83 184.519 402.586 185.369ZM408.322 164.962C407.26 165.966 406.198 166.969 405.135 167.973C406.663 168.204 408.191 168.435 409.718 168.667C409.465 167.645 409.212 166.622 408.322 164.962Z" fill="black"/></svg>',
                            title: 'Seta artística 1'
                        },
                        // Arrow-13 - Selecionado da pasta
                        {
                            svg: '<svg viewBox="0 0 534 534" width="24" height="24"><path d="M241.944 295.281C222.55 310.783 203.758 325.715 184.909 340.578C183.514 341.678 181.755 342.869 180.103 342.967C177.093 343.147 174.037 342.538 171 342.259C172.236 339.646 172.795 336.202 174.816 334.552C189.328 322.703 204.158 311.246 218.844 299.609C234.138 287.49 249.249 275.137 264.678 263.195C292.725 241.485 320.852 219.876 349.127 198.466C371.959 181.178 395.024 164.199 418.073 147.202C421.879 144.395 425.889 141.295 430.285 140.09C432.665 139.438 436.062 142.503 439 143.892C437.928 146.102 437.445 149.134 435.692 150.396C416.494 164.217 396.842 177.416 377.815 191.464C349.933 212.049 322.398 233.106 294.834 254.12C277.287 267.497 259.957 281.159 241.944 295.281Z" fill="black"/></svg>',
                            title: 'Seta artística 2'
                        },
                        // Arrow-28 - Versão simplificada/compatível
                        {
                            svg: '<svg viewBox="0 0 534 534" width="24" height="24"><path d="M220 150C280 220 300 300 330 370C340 390 370 410 400 420" fill="none" stroke="black" stroke-width="20" stroke-linecap="round" stroke-linejoin="round"/><path d="M380 380L410 430L440 390" fill="none" stroke="black" stroke-width="20" stroke-linecap="round" stroke-linejoin="round"/></svg>',
                            title: 'Seta curva artística'
                        },
                        // Curva estilo "sdd copy"
                        {
                            svg: '<svg viewBox="0 0 800 400" width="24" height="24"><path d="M144,142C183,141,347,153,375,138C402,124,281,55,308,56C335,57,535,107,538,146C540,184,352,281,325,289C298,297,407,207,376,191C346,175,182,200,143,192C105,184,145,150,145,142" fill="none" stroke="black" stroke-width="25" stroke-linecap="round"></path></svg>',
                            title: 'Curva livre'
                        }
                    ]
                },
                {
                    title: 'Símbolos de Verificação',
                    items: [
                        // Check simples
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M5,12L10,17L19,8" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
                            title: 'Check'
                        },
                        // Check duplo
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M5,15L9,19L19,7 M5,9L9,13L13,9" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
                            title: 'Check duplo'
                        },
                        // Check com círculo
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><circle cx="12" cy="12" r="9" fill="none" stroke="black" stroke-width="2"/><path d="M8,12L10.5,14.5L16,9" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
                            title: 'Check com círculo'
                        },
                        // Check com quadrado
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><rect x="4" y="4" width="16" height="16" rx="2" fill="none" stroke="black" stroke-width="2"/><path d="M9,12L11,14L15,10" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>',
                            title: 'Check com quadrado'
                        },
                        // Check negativo
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><circle cx="12" cy="12" r="9" fill="none" stroke="black" stroke-width="2"/><path d="M8,8L16,16 M8,16L16,8" fill="none" stroke="black" stroke-width="2" stroke-linecap="round"/></svg>',
                            title: 'X em círculo'
                        },
                        // X simples
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M6,6L18,18 M6,18L18,6" fill="none" stroke="black" stroke-width="2" stroke-linecap="round"/></svg>',
                            title: 'X'
                        }
                    ]
                },
                {
                    title: 'Formas Básicas',
                    items: [
                        // Retângulo
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><rect x="4" y="6" width="16" height="12" fill="none" stroke="black" stroke-width="2" rx="0"/></svg>',
                            title: 'Retângulo'
                        },
                        // Retângulo arredondado
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><rect x="4" y="6" width="16" height="12" fill="none" stroke="black" stroke-width="2" rx="2"/></svg>',
                            title: 'Retângulo arredondado'
                        },
                        // Círculo
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><circle cx="12" cy="12" r="8" fill="none" stroke="black" stroke-width="2"/></svg>',
                            title: 'Círculo'
                        },
                        // Elipse
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><ellipse cx="12" cy="12" rx="8" ry="5" fill="none" stroke="black" stroke-width="2"/></svg>',
                            title: 'Elipse'
                        },
                        // Triângulo
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><polygon points="12,4 20,18 4,18" fill="none" stroke="black" stroke-width="2"/></svg>',
                            title: 'Triângulo'
                        },
                        // Estrela
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26" fill="none" stroke="black" stroke-width="1.5"/></svg>',
                            title: 'Estrela'
                        }
                    ]
                },
                {
                    title: 'Formas Especiais',
                    items: [
                        // Coração
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z" fill="none" stroke="black" stroke-width="1.5"/></svg>',
                            title: 'Coração'
                        },
                        // Nuvem
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M5.5,15C3.57,15 2,13.43 2,11.5C2,9.57 3.57,8 5.5,8C5.89,8 6.26,8.07 6.6,8.21C7.22,6.36 9.08,5 11.25,5C13.96,5 16.19,7.1 16.46,9.73C17.37,10.04 18.1,10.73 18.51,11.61C19.44,11.13 20.56,11.53 21.04,12.46C21.53,13.38 21.13,14.5 20.21,14.99C19.33,15.45 18.28,15.06 17.77,14.21C17.46,14.32 17.13,14.38 16.78,14.38C15.28,14.38 14.02,13.21 13.89,11.75C13.3,10.95 12.69,10.85 12,10.85C10.5,10.85 9.27,12.05 9.25,13.5C9.25,14.05 9.4,14.56 9.67,15H5.5Z" fill="none" stroke="black" stroke-width="1.5"/></svg>',
                            title: 'Nuvem'
                        },
                        // Documento
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M14,2H6C4.9,2 4,2.9 4,4V20C4,21.1 4.9,22 6,22H18C19.1,22 20,21.1 20,20V8L14,2Z" fill="none" stroke="black" stroke-width="1.5"/><path d="M14,2V8H20" fill="none" stroke="black" stroke-width="1.5"/><line x1="16" y1="13" x2="8" y2="13" stroke="black" stroke-width="1.5"/><line x1="16" y1="17" x2="8" y2="17" stroke="black" stroke-width="1.5"/><line x1="10" y1="9" x2="8" y2="9" stroke="black" stroke-width="1.5"/></svg>',
                            title: 'Documento'
                        },
                        // Balão de diálogo
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><path d="M3,12c0,4.97,4.03,9,9,9c0.34,0,0.67-0.02,1-0.06V24l5-5h3c4.97,0,9-4.03,9-9s-4.03-9-9-9H12C7.03,3,3,7.03,3,12z" fill="none" stroke="black" stroke-width="1.5" stroke-linejoin="round"/></svg>',
                            title: 'Balão de diálogo'
                        },
                        // Raio/relâmpago
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><polygon points="13,2 4,14 11,14 11,22 20,10 13,10" fill="none" stroke="black" stroke-width="1.5" stroke-linejoin="round"/></svg>',
                            title: 'Raio'
                        },
                        // Engrenagem
                        {
                            svg: '<svg viewBox="0 0 24 24" width="24" height="24"><circle cx="12" cy="12" r="3" fill="none" stroke="black" stroke-width="1.5"/><path d="M20,12c0-0.34-0.03-0.67-0.07-1l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61l-1.92-3.32c-0.12-0.2-0.36-0.31-0.57-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94l-0.36-2.54C15.18,2.36,14.9,2,14.56,2h-3.83c-0.34,0-0.62,0.24-0.67,0.57L9.7,5.1C9.11,5.34,8.57,5.65,8.08,6.03L5.69,5.07C5.47,4.98,5.24,5.08,5.12,5.28L3.2,8.6C3.08,8.8,3.13,9.06,3.31,9.21L5.34,10.8C5.31,11.12,5.28,11.46,5.28,11.79s0.03,0.67,0.07,1l-2.03,1.58c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.2,0.36,0.31,0.57,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54c0.05,0.32,0.33,0.57,0.67,0.57h3.83c0.34,0,0.62-0.24,0.67-0.57l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96c0.22,0.09,0.45-0.01,0.57-0.22l1.92-3.32c0.12-0.2,0.07-0.47-0.12-0.61L20.07,13C20.1,12.67,20.12,12.34,20.12,12L20,12z" fill="none" stroke="black" stroke-width="1.5"/></svg>',
                            title: 'Engrenagem'
                        }
                    ]
                }
            ];
            
            // Para cada categoria
            svgCategories.forEach(category => {
                // Criar título da categoria
                const categoryTitle = document.createElement('h3');
                categoryTitle.textContent = category.title;
                categoryTitle.style.margin = '15px 0 5px 0';
                categoryTitle.style.fontSize = '14px';
                categoryTitle.style.fontWeight = 'bold';
                categoryTitle.style.borderBottom = '1px solid #ddd';
                categoryTitle.style.paddingBottom = '4px';
                categoryTitle.style.color = '#333';
                container.appendChild(categoryTitle);
                
                // Criar container para os itens desta categoria
                const categoryContainer = document.createElement('div');
                categoryContainer.style.display = 'flex';
                categoryContainer.style.flexWrap = 'wrap';
                categoryContainer.style.justifyContent = 'flex-start';
                categoryContainer.style.gap = '8px';
                categoryContainer.style.marginBottom = '10px';
                categoryContainer.style.marginTop = '5px';
                categoryContainer.style.textAlign = 'center';
                categoryContainer.style.marginLeft = '10px';
                categoryContainer.style.marginRight = '10px';
                categoryContainer.style.marginTop = '10px';
                categoryContainer.style.marginBottom = '10px';
                container.appendChild(categoryContainer);
                
                // Para cada SVG nesta categoria
                category.items.forEach((item, index) => {
                    // Criar um botão para o SVG
                    const button = document.createElement('button');
                    
                    // Definir o conteúdo do botão com o SVG
                    button.innerHTML = `<div style="width: 45px; height: 45px; display: flex; align-items: center; justify-content: center; overflow: hidden;">${item.svg}</div>`;
                    
                    button.style.width = '60px';
                    button.style.height = '60px';
                    button.style.padding = '3px';
                    button.style.border = '1px solid #ddd';
                    button.style.background = 'white';
                    button.style.cursor = 'pointer';
                    button.style.borderRadius = '4px';
                    button.style.display = 'flex';
                    button.style.alignItems = 'center';
                    button.style.justifyContent = 'center';
                    button.title = item.title || `SVG ${index + 1}`;
                    
                    button.addEventListener('mouseover', () => {
                        button.style.backgroundColor = '#f0f8ff';
                        button.style.borderColor = '#add8e6';
                        button.style.boxShadow = '0 0 3px rgba(0,0,0,0.1)';
                    });
                    
                    button.addEventListener('mouseout', () => {
                        button.style.backgroundColor = 'white';
                        button.style.borderColor = '#ddd';
                        button.style.boxShadow = 'none';
                    });
                    
                    // Adicionar ação ao clicar no botão
                    button.addEventListener('click', () => {
                        console.log(`Adicionando SVG: ${item.title || `SVG ${index + 1}`}`);
                        
                        fabric.loadSVGFromString(item.svg, function(objects, options) {
                            try {
                                // Criar um grupo com todos os objetos do SVG
                                const svgGroup = fabric.util.groupSVGElements(objects, options);
                                
                                // Ajustar o tamanho
                                const maxSize = 100;
                                if (svgGroup.width > maxSize || svgGroup.height > maxSize) {
                                    const scale = maxSize / Math.max(svgGroup.width, svgGroup.height);
                                    svgGroup.scale(scale);
                                }
                                
                                // Posicionar no centro da tela
                                svgGroup.set({
                                    left: canvas.width / 2,
                                    top: canvas.height / 2,
                                    originX: 'center',
                                    originY: 'center',
                                    fill: document.getElementById('colorPicker')?.value || '#000000'
                                });
                                
                                // Adicionar ao canvas
                                canvas.add(svgGroup);
                                canvas.setActiveObject(svgGroup);
                                canvas.renderAll();
                                
                                // Fechar o menu
                                document.getElementById('shapesDropdown').style.display = 'none';
                                
                                // Mostrar menu de configuração
                                hideAllConfigMenus();
                                const shapeConfigMenu = document.getElementById('shapeConfigMenu');
                                if (shapeConfigMenu) {
                                    shapeConfigMenu.style.display = 'block';
                                }
                                
                                if (typeof updateShapeMenu === 'function') {
                                    updateShapeMenu(svgGroup);
                                }
                                
                                console.log('SVG adicionado ao canvas com sucesso');
                            } catch (error) {
                                console.error('Erro ao processar SVG:', error);
                                alert('Erro ao adicionar SVG: ' + error.message);
                            }
                        });
                    });
                    
                    // Adicionar o botão ao container da categoria
                    categoryContainer.appendChild(button);
                });
            });
            
            // Adicionar uma mensagem informativa
            const infoMsg = document.createElement('div');
            infoMsg.textContent = 'Clique em qualquer forma para adicioná-la ao canvas';
            infoMsg.style.padding = '10px';
            infoMsg.style.fontSize = '12px';
            infoMsg.style.color = '#666';
            infoMsg.style.marginTop = '5px';
            infoMsg.style.fontStyle = 'italic';
            infoMsg.style.textAlign = 'center';
            container.appendChild(infoMsg);
            
            console.log('Formas e SVGs adicionados com sucesso!');
        }
    </script>
</body>
    <!-- Meus scripts de correção -->
    <script src="fabric-history-fix.js"></script>
    <script src="inline-undo-redo.js"></script>
    <script src="order-button-final-fix.js"></script>
    <script src="slider-fix.js"></script>
    <script src="text-shadow-fix.js"></script>
    <script src="path-fill-fix.js"></script>
    <script src="menu-fix.js"></script>
    <script src="undo-redo-fix.js"></script>
    <script src="keyboard-controls-fix.js"></script>
    <script src="order-menu-fix.js"></script>
    <script src="dashboard-mode-fix.js"></script>
    <script src="pen-tool.js"></script>
</html>